(self.webpackChunklinq_js_docs=self.webpackChunklinq_js_docs||[]).push([[799],{76465:e=>{e.exports={constructors:{historys:[{overloads:[{description:"Create an object of type IEnumerable from source"}]}]},name:"Enumerable",properties:[{name:"actions",historys:[{deprecated:0,description:"An object contains same useful actions"}]},{name:"comparers",historys:[{deprecated:0,description:"An object contains same useful comparers"}]},{name:"config",historys:[{deprecated:0,description:"Global config"}]},{name:"predicates",historys:[{deprecated:0,description:"An object contains same useful predicates"}]},{name:"selectors",historys:[{deprecated:0,description:"An object contains same useful selectors"}]}],methods:[{name:"asEnumerable",historys:[{deprecated:0,overloads:[{description:"Create an object of type IEnumerable from source"}]}]},{name:"empty",historys:[{deprecated:0,overloads:[{description:"Create an empty IEnumerable object"}]}]}]}},12565:e=>{e.exports={constructors:{historys:[{overloads:[{description:"Create an object of type IEnumerable from source"}]}]}}},86290:e=>{e.exports={historys:[{overloads:[{description:"Create an object of type IEnumerable from source"}]}]}},26149:e=>{e.exports={historys:[{overloads:[{description:"Create an empty IEnumerable object"}]}]}},77003:e=>{e.exports={historys:[{description:"An object contains same useful actions"}]}},16659:e=>{e.exports={historys:[{description:"An object contains same useful comparers"}]}},61117:e=>{e.exports={historys:[{description:"Global config"}]}},12527:e=>{e.exports={historys:[{description:"An object contains same useful predicates"}]}},91509:e=>{e.exports={historys:[{description:"An object contains same useful selectors"}]}},7221:e=>{e.exports={class:"class",interface:"interface",object:"object",constructor:"constructor",constructors:"constructors",property:"property",properties:"properties",method:"method",methods:"methods",since:"since",deprecated:"deprecated",details:"details",description:"description",summary:"summary",warning:"warning",warnings:"warnings",remark:"remark",remarks:"remarks",example:"example",examples:"examples",static:"static",new:"new",see:"see",declare:"declare",parameters:"parameters",parameter:"parameter",returns:"return value",generics:"type parameters",apis:"APIs",guide:"Guide",publish:"publish",time:"time",date:"date",prepublish:"prepublish",version:"version",author:"author",email:"email",project:"project",default:"default",value:"value",defaultValue:"default value",readonly:"readonly",lazy:"deferred execution",try:"try it",run:"run",clear:"clear",close:"close",loadRuntime:"loading runtime",executing:"executing",enableExtend:"enable extends of Array",newInstance:{only:"can only use new operator",both:"can use new operator or not",cannot:"can not use new operator"}}},5900:e=>{e.exports=[{publish:"2017-03-27",contents:["优化了部分代码结构","新增 对 arrayComparer 的默认支持","新增了 对绝大部分 selector, predicate, comparer 参数校验","新增 绝大部分的 selector, predicate, comparer 参数均支持 String 或 Symbol 类型数据 表示选择对象对应的字段 的功能","新增 Enumerable.predicates.exists 属性, 表示非空筛选器","新增 Enumerable.predicates.regexp 方法, 生成正则匹配的筛选器","新增 Enumerable.predicates.not 方法, 生成逻辑非筛选器","新增 Enumerable.predicates.selector 方法, 生成选择筛选器","新增 Enumerable.predicates.equality, Enumerable.predicates.strict, Enumerable.predicates.same 方法, 生成比较筛选器"],version:"2.1.15"},{publish:"2017-04-05",contents:["优化 selectMany 方法, 使的使用上更接近linq原生的方法. 修复 selectMany 方法 collectionSelector 返回 Iterator,string,object 对象是出现异常的bug","修改 defaultGroupResultSelector 为 defaultResultSelector, 修改 Enumerable.selectors.groupResult 为 Enumerable.selectors.result","修改 selectMany 方法的 resultSelector 参数的结构和默认值, 与 defaultResultSelector 一致","增加 zip 方法的 resultSelector 的默认值为 defaultResultSelector"],version:"2.1.16"},{publish:"2017-04-12",contents:["新增 findLast 方法","新增 Enumerable.comparers.greater 方法","新增 Enumerable.comparers.less 方法","新增 Enumerable.predicates.properties 方法, 生成一个属性筛选器","新增所有的 predicate 参数, 如果使用 Array 或者 Object 类型作为参数时, 自动经过 Enumerable.predicates.properties 方法转译成一个筛选器","优化 comparer / predicate / selector 类型的参数 转化过程的效率"],version:"2.1.17"},{publish:"2017-08-30",contents:["新增 Enumerable.typeAs 方法用来对指定类型设置 asEnumerable 转换时的参考类型","新增 Enumerable.types 对象,包含各参考类型的常量值","Enumerable.addPlugins、Enumerable.removePlugins 方法增加返回值,方便链式调用","新增 Enumerable.comparers.ignoreCase 忽略大小写的相等比较器","新增 IEnumerable.prototype.leftJoin、IEnumerable.prototype.rightJoin 方法用来对两个序列分别进行内部左联接与内部右联接","修复 concat 方法在参数值为 String 或 Arguments 类型是结果超出预期的bug","移除过时的功能 arrayComparer、predicateComparer","新增 Enumerable.extends.lazy 配置选项","修复 启用扩展后 对象上不能使用 getEnumerator 方法的问题","新增 IEnumerable.prototype.chunk 方法用来对序列进行分块","新增 IEnumerable.prototype.product 方法用来计算乘积","新增 IEnumerable.prototype.leftPad、IEnumerable.prototype.rightPad 方法","新增 IEnumerable.prototype.rand 方法","","Bugs","调用 Object 对象的 asEnumerable 方法将会返回一个不可控的结果"],version:"2.1.18"},{publish:"2017-09-08",contents:["新增(New):","1. 增加各 选择器(Selector)/比较器(Comparer)/筛选器(Predicate) 对 Number/Symbol 类型参数的支持","2. 新增 Enumerable.selectors.join 作为 defaultJoinSelector","3. 新增 IEnumerable.prototype.innerJoin 方法与原先的 join 方法功能一致, 主要为了区别仅有一个参数的情况下的逻辑","4. 新增 Enumerable.noConflict 方法 用于解决重复引用的问题","","优化(Optimization):","1. 优化了 join 方法的处理逻辑","2. 将 IGrouping.prototype.key 与 IChunk.prototype.index 设置成只读","3. 为 groupJoin, leftJoin, rightJoin 等方法的 resultSelector 参数设置了 defaultJoinSelector 默认值","4. 优化了 Enumerable.extend/Enumerable.unextend/Enumerable.addPlugins/Enumerble.removePlugins 等方法, 并新增了 Enumerable.extendAll/Enumerable.unextendAll 方法","","修复(Fixed):","1. 修复一处针对 String 扩展后 String.prototype.slice 返回超出预期的问题","2. 修复由 groupBy/groupJoin/chunk 等方法获取到的 IGrouping/IChunk 对象不能被重复遍历的问题","3. 修复对 Object 对象使用 asEnumerable 方法时不能返回此对象键值对序列或出现错误的bug"],version:"2.1.19"},{publish:"2017-09-22",contents:["新增(New):","1. 新增 IEnumerable.prototype.random / IEnumerable.prototype.randomOrDefault 方法, 用来从序列中随机获取一个元素","2. 新增 IEnumerable.prototype.wipe 方法, 用来剔除序列中满足条件指定数量的元素","3. 新增 IEnumerable.prototype.nearBy 方法, 用来对序列中相同且相邻的元素进行分组","4. 新增 Enumerable.between 方法, 生成范围内的整数序列","5. 新增 Enumerable.from 方法, 功能与 asEnumerable 方法一致","6. 为 Enumerable.range 方法新增第三个参数, 设置步长","7. 新增 Enumerable.generate 方法, 通过生成方法构建新序列","8. 新增 IEnumerable.prototype.separate / IEnumerable.prototype.combine 方法, 分别用来对递归的结构进行拆解与合并","","优化(Optimization):","1. 优化 chunk/leftPad/rightPad/rand 方法的逻辑","2. 优化 defaultValueSelector","","修复(Fixed):","1. 修复 开启扩展后 average/defaultIfEmpty/join 方法返回超出预期或报错的bug"],version:"2.1.20"},{publish:"2017-11-20",contents:["新增(New):","1. 新增 IEnumerable.prototype.isSub / IEnumerable.prototype.isSuper 方法, 用来判断两个序列的从属关系","2. 新增 IEnumerable.prototype.symmetric 方法, 用来计算两个序列的对称差集","","优化(Optimization):","1. 优化 orderBy/orderByDescending/thenBy/thenByDescending 方法的性能","","修复(Fixed):"],version:"2.1.21"},{publish:"2018-03-21",contents:["新增(New):","1. 新增 ITree 接口, 拥有对树形结构的基本操作. 包含: value, children, values 等属性, 包含: depth, degree, getChild, getValue, breadthTraverse, breadthSearch, breadthSubTree, depthTraverse, depthSearch, depthSubTree, lowestAncestor, isDescendantOf, isAncestorOf, path, pathTo, isBinary, isFullBinary, isCompleteBinary, isProfectBinary, asBinary 等方法","2. 新增 BinaryTree 类, 拥有对二叉树的基本操作. 包含: left, right 等属性, 包含: hasLeft, hasRight, preOrder, inOrder, postOrder 等方法","3. 修改 ICombine 继承 ITree 接口, 可进行树形结构的操作","4. 新增 IEnumerable.prototype.maxOrDefault, IEnumerable.prototype.minOrDefault 方法","5. 为 object 对象新增 asEnumerable(childrenSelector, valueSelector) 重载, 用于或一个 ITree 对象","6. 新增 toPreOrder, toInOrder, toPostOrder 方法, 用于生成一个完全二叉树, 分别使得此二叉树的 前序遍历|中序遍历|后序遍历 的结果与源序列一致","","优化(Optimization):","1. 优化 IteratorEnumerable","","修复(Fixed):"],version:"2.1.22"},{publish:"2018-03-29",contents:["新增(New):","1. 增加 ITree.prototype.toValue 方法,将树形结构转化 object 对象 ( JSON 数据 )","2. 增加 ITree.prototype.isParentOf, ITree.prototype.isChildOf, ITree.prototype.getParent, ITree.prototype.prev, ITree.prototype.prevAll, ITree.prototype.next, ITree.prototype.nextAll, ITree.prototype.siblings, ITree.prototype.getParentNode, ITree.prototype.prevNode, ITree.prototype.prevAllNodes, ITree.prototype.nextNode, ITree.prototype.nextAllNodes, ITree.prototype.siblingNodes, ITree.prototype.pathNodes, ITree.prototype.pathNodesTo 方法,操作树形的各节点关系","3. 增加 IEnumerable.prototype.each 方法,对序列中的每个元素执行一次操作,并返回序列本身 ( 与 forEach 方法的区别在于 each 方法可以继续链式调用 )","4. 增加 IEnumerable.prototype.split 方法,对序列按照指定的条件进行拆分","5. 增加 IEnumerable.prototype.indices 方法,用使用一个索引序列从源序列中生成一个新序列","6. 增加 IEnumerable.prototype.permutation, IEnumerable.prototype.combination 方法,用来计算排列与组合","7. 增加 Enumerable.setters.children, Enumerable.setters.value 属性,一个默认的 children/value 设置器","8. 增加 Enumerable.setters.property 方法,用来生成一个属性设置器","","优化(Optimization):","1. 优化 ITree.prototype.isAncestorOf, ITree.prototype.isDescendantOf 方法的性能","2. 优化 IEnumerable.prototype.chunk, IEnumerable.prototype.groupBy, IEnumerable.prototype.groupJoin 等方法性能","3. 优化 ITree.prototype.lowestAncestor 方法的性能","4. 优化 Enumerable.selectors.property 方法, 增加一个参数控制是否忽略无效的属性","","修复(Fixed):","1. 修复 ITree.prototype.lowestAncestor 在处理节点值为false的情况下返回错误的问题","2. 修复 ITree.prototype.lowestAncestor 在处理节点值类型与参数值类型不同但数值相等的情况下返回错误的问题"],version:"2.1.23"},{publish:"2020-03-03",contents:["新增(New):","1. 为一些方法增加别名, 方便其他语言使用者更容易的转移","2. 新增 conflict 方法用来判断一个序列中是否包含重复的元素","3. 新增 nearSplit 方法用来分割一个序列,与 split 方法区别在于连续的符合条件的分割元素之间将不会被分割出空序列","4. 新增 skipSame, takeSame 方法用来获取或忽略开头部分相同的元素","","优化(Optimization):","","修复(Fixed):","1. 修复 skipWhile, takeWhile 方法默认参数错误的bug"],version:"2.1.24"},{prepublish:!0,contents:["新增(New):","1. 增加 proportion、skipProportion, takeProportion 方法","","优化(Optimization):","","修复(Fixed):","1. 修复了 IEnumerable 中未注册 random、 randomOrDefault 方法的问题"],version:"2.1.25.pre"}]},19749:e=>{e.exports=[{code:"introduction",title:"Introduction"},{code:"install",title:"Install"},{code:"guides",title:"Guide",children:[{code:"instance",title:"Get IEnumerable instance",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"use",title:"Start use",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"config",title:"Configuration",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"selector",title:"Selector",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"predicate",title:"Predicate",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"comparer",title:"Comparer",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"action",title:"Action",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"setter",title:"设置器",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"iterator",title:"迭代器",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"enumerator",title:"枚举器",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"extend",title:"扩展",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"plugin",title:"插件",since:"2.1.15",deprecated:"2.1.25.pre"}]},{code:"apis",title:"APIs",children:[{code:"BinaryTree",title:"BinaryTree Class",since:"2.1.22",deprecated:"2.1.25.pre"},{code:"Directory",title:"Directory Class",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Entry",title:"Entry Class",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable",title:"Enumerable Class",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.actions",title:"Enumerable.actions Object",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.comparers",title:"Enumerable.comparers Object",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.config",title:"Enumerable.config Object",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.predicates",title:"Enumerable.predicates Object",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.selectors",title:"Enumerable.selectors Object",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Enumerable.setters",title:"Enumerable.setters Object",since:"2.1.20",deprecated:"2.1.25.pre"},{code:"IChunk",title:"IChunk Interface",since:"2.1.18",deprecated:"2.1.25.pre"},{code:"ICombine",title:"ICombine Interface",since:"2.1.22",deprecated:"2.1.25.pre"},{code:"IEnumerable",title:"IEnumerable Interface",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"IEnumerator",title:"IEnumerator Interface",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"IGrouping",title:"IGrouping Interface",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"IMapEnumerable",title:"IMapEnumerable Interface",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"IOrderedEnumerable",title:"IOrderedEnumerable Interface",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"ITree",title:"ITree Interface",since:"2.1.22",deprecated:"2.1.25.pre"},{code:"Lookup",title:"Lookup Class",since:"2.1.15",deprecated:"2.1.25.pre"},{code:"Plugin",title:"Plugin Class",since:"2.1.15",deprecated:"2.1.25.pre"}]},{code:"change",title:"Change List"},{code:"about",title:"About"}]},21167:e=>{e.exports=[{code:"introduction",title:"Introduction"},{code:"install",title:"Install"},"guides","apis",{code:"change",title:"Change List"},{code:"about",title:"About"}]},55166:e=>{e.exports={}},13273:e=>{e.exports={"1.js":'let fruits = [ "apple", "mango", "orange", "passionfruit", "grape" ];\r\n\r\n// Determine whether any string in the array is longer than "banana".\r\nlet longestName =\r\n    fruits.asEnumerable().aggregate("banana",\r\n        (longest, next) =>\r\n            next.length > longest.length ? next : longest,\r\n        // Return the final result as an upper case string.\r\n        fruit => fruit.toUpperCase());\r\n\r\nconsole.log(`The fruit with the longest name is ${ longestName }`);\r\n\r\n// This code produces the following output:\r\n//\r\n// The fruit with the longest name is PASSIONFRUIT.'}},31386:e=>{e.exports={"1.js":'// Create an array of Pets.\r\nlet pets = [\r\n    { name: "Barley", age: 10 },\r\n    { name: "Boots", age: 14 },\r\n    { name: "Whiskers", age: 6 }\r\n];\r\n\r\n// Determine whether all pet names\r\n// in the array start with \'B\'.\r\nlet allStartWithB = pets.asEnumerable().all(pet => pet.name.startsWith("B"));\r\n\r\nconsole.log(`${ allStartWithB ? "All" : "Not all" } pet names start with \'B\'.`);\r\n\r\n// This code produces the following output:\r\n//\r\n//  Not all pet names start with \'B\'.',"2.js":'let people = [\r\n    {\r\n        lastName: "Haas",\r\n        pets: [\r\n            { name: "Barley", age: 10 },\r\n            { name: "Boots", age: 14 },\r\n            { name: "Whiskers", age: 6 }\r\n        ]\r\n    },\r\n    {\r\n        lastName: "Fakhouri",\r\n        pets: [\r\n            { name: "Snowball", age: 1 }\r\n        ]\r\n    },\r\n    {\r\n        lastName: "Antebi",\r\n        pets: [\r\n            { name: "Belle", age: 8 }\r\n        ]\r\n    },\r\n    {\r\n        lastName: "Philips",\r\n        pets: [\r\n            { name: "Sweetie", age: 2 },\r\n            { name: "Rover", age: 13 }\r\n        ]\r\n    }\r\n];\r\n\r\n// Determine which people have pets that are all older than 5.\r\nlet names = people.asEnumerable().where(person => person.pets.all(pet => pet.age > 5)).select(person => person.lastName);\r\n\r\nfor (let name of names) {\r\n    console.log(name);\r\n}\r\n\r\n/* This code produces the following output:\r\n *\r\n * Haas\r\n * Antebi\r\n */'}},33564:e=>{e.exports={"1.js":'// Create an array of Pets.\r\nlet pets = [\r\n    { name: "Barley", age: 8, vaccinated: true },\r\n    { name: "Boots", age: 4, vaccinated: false },\r\n    { name: "Whiskers", age: 1, vaccinated: false }\r\n];\r\n\r\n// Determine whether any pets over age 1 are also unvaccinated.\r\nlet unvaccinated = pets.asEnumerable().any(p => p.age > 1 && p.vaccinated === false);\r\n\r\nconsole.log(`There ${ unvaccinated ? "are" : "are not any" } unvaccinated animals over age one.`);\r\n\r\n// This code produces the following output:\r\n//\r\n//  There are unvaccinated animals over age one.'}},68414:e=>{e.exports={"1.js":'let numbers = [ "10007", "37", 299846234235 ];\r\n\r\nlet average = numbers.asEnumerable().average();\r\n\r\nconsole.log(`The average is ${ average }.`);\r\n\r\n// This code produces the following output:\r\n//\r\n// The average is 99948748093.'}},92595:e=>{e.exports={"1.js":'let cats = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 }\r\n];\r\n\r\nlet dogs = [\r\n    { name: "Bounder", age: 3 },\r\n    { name: "Snoopy", age: 14 },\r\n    { name: "Fido", age: 9 }\r\n];\r\n\r\nlet query = cats.asEnumerable().select(cat => cat.name)\r\n    .concat(dogs.asEnumerable().select(dog => dog.name));\r\n\r\nfor (let name of query) {\r\n    console.log(name);\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// Barley\r\n// Boots\r\n// Whiskers\r\n// Bounder\r\n// Snoopy\r\n// Fido'}},50318:e=>{e.exports={"1.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet fruit = "mango";\r\n\r\nlet hasMango = fruits.asEnumerable().contains(fruit);\r\n\r\nconsole.log(`The array ${ hasMango ? "does" : "does not" } contain \'${ fruit }\'.`);\r\n\r\n// This code produces the following output:\r\n//\r\n// The array does contain \'mango\'.',"2.js":'// Custom comparer for contains\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // Fruits are equal if their names and product numbers are equal.\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet fruits = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 },\r\n    { name: "lemon", code: 12 }\r\n];\r\n\r\nlet apple = { name: "apple", code: 9 };\r\nlet kiwi = { name: "kiwi", code: 8 };\r\n\r\nlet hasApple = fruits.asEnumerable().contains(apple, productComparer);\r\nlet hasKiwi = fruits.asEnumerable().contains(kiwi, productComparer);\r\n\r\nconsole.log("Apple? " + hasApple);\r\nconsole.log("Kiwi? " + hasKiwi);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Apple? true\r\n Kiwi? false\r\n */'}},22909:e=>{e.exports={"1.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet numberOfFruits = fruits.asEnumerable().count();\r\n\r\nconsole.log(`There are ${ numberOfFruits } fruits in the collection.`);\r\n\r\n// This code produces the following output:\r\n//\r\n// There are 6 fruits in the collection.\r\n',"2.js":'let pets = [\r\n    { name: "Barley", vaccinated: true },\r\n    { name: "Boots", vaccinated: false },\r\n    { name: "Whiskers", vaccinated: false }\r\n];\r\n\r\nlet numberUnvaccinated = pets.asEnumerable().count(p => p.vaccinated === false);\r\n\r\nconsole.log(`There are ${ numberUnvaccinated } unvaccinated animals.`);\r\n\r\n// This code produces the following output:\r\n//\r\n// There are 2 unvaccinated animals.',"3.js":'let pets = [\r\n    { name: "Barley", vaccinated: true },\r\n    { name: "Boots", vaccinated: false },\r\n    { name: "Whiskers", vaccinated: false }\r\n];\r\n\r\nlet numberUnvaccinated = pets.asEnumerable().count({ vaccinated: false });\r\n\r\nconsole.log(`There are ${ numberUnvaccinated } unvaccinated animals.`);\r\n\r\n// This code produces the following output:\r\n//\r\n// There are 2 unvaccinated animals.'}},91412:e=>{e.exports={"1.js":'let defaultPet = { name: "Default Pet Name", age: 0 };\r\n\r\nlet pets1 = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 }\r\n];\r\n\r\nfor (let pet of pets1.asEnumerable().defaultIfEmpty(defaultPet)) {\r\n    console.log(`Name: ${ pet.name }`);\r\n}\r\n\r\nconsole.log();\r\n\r\nlet pets2 = [];\r\n\r\nfor (let pet of pets2.asEnumerable().defaultIfEmpty(defaultPet)) {\r\n    console.log(`Name: ${ pet.name }`);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Name: Barley\r\n Name: Boots\r\n Name: Whiskers\r\n\r\n Name: Default Pet Name\r\n */'}},50930:e=>{e.exports={"1.js":'let ages = [ 21, 46, 46, 55, 17, 21, 55, 55 ];\r\n\r\nlet distinctAges = ages.asEnumerable().distinct();\r\n\r\nconsole.log("Distinct ages:");\r\n\r\nfor (let age of distinctAges) {\r\n    console.log(age);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Distinct ages:\r\n 21\r\n 46\r\n 55\r\n 17\r\n */\r\n',"2.js":'// Custom comparer for distinct\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // Check whether the products\' properties are equal.\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet products = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 },\r\n    { name: "apple", code: 9 },\r\n    { name: "lemon", code: 12 }\r\n];\r\n\r\n// Exclude duplicates.\r\nlet noduplicates = products.distinct(productComparer);\r\n\r\nfor (let product of noduplicates) {\r\n    console.log(product.name + " " + product.code);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n apple 9\r\n orange 4\r\n lemon 12\r\n */'}},11190:e=>{e.exports={"1.js":'let names = [ "Hartono, Tommy", "Adams, Terry", "Andersen, Henriette Thaulow", "Hedlund, Magnus", "Ito, Shu" ];\r\n\r\nlet name = names.asEnumerable().elementAt(4);\r\n\r\nconsole.log(`The name is \'${ name }\'.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The name is \'Ito, Shu\'.\r\n */'}},56138:e=>{e.exports={"1.js":'let names = [ "Hartono, Tommy", "Adams, Terry", "Andersen, Henriette Thaulow", "Hedlund, Magnus", "Ito, Shu" ];\r\n\r\nlet index = 20;\r\n\r\nlet name = names.asEnumerable().elementAtOrDefault(index, "[no name at this index]");\r\n\r\nconsole.log(`The name chosen at index ${ index } is \'${ name }\'.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The name chosen at index 20 is \'[no name at this index]\'.\r\n */'}},20369:e=>{e.exports={"1.js":"let numbers1 = [ 2.0, 2.0, 2.1, 2.2, 2.3, 2.3, 2.4, 2.5 ];\r\nlet numbers2 = [ 2.2 ];\r\n\r\nlet onlyInFirstSet = numbers1.asEnumerable().except(numbers2);\r\n\r\nfor (let number of onlyInFirstSet) {\r\n    console.log(number);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 2\r\n 2.1\r\n 2.3\r\n 2.4\r\n 2.5\r\n */","2.js":'// Custom comparer for distinct\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // Check whether the products\' properties are equal.\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet fruits1 = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 },\r\n    { name: "lemon", code: 12 }\r\n];\r\n\r\nlet fruits2 = [ { name: "apple", code: 9 } ];\r\n\r\n//Get all the elements from the first array\r\n//except for the elements from the second array.\r\nlet except = fruits1.asEnumerable().except(fruits2, productComparer);\r\n\r\nfor (let product of except) {\r\n    console.log(product.name + " " + product.code);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n orange 4\r\n lemon 12\r\n */'}},46332:e=>{e.exports={"1.js":"let numbers = [ 9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19 ];\r\n\r\nlet first = numbers.asEnumerable().first();\r\n\r\nconsole.log(first);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 9\r\n */","2.js":"let numbers = [ 9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19 ];\r\n\r\nlet first = numbers.asEnumerable().first(number => number > 80);\r\n\r\nconsole.log(first);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 92\r\n */"}},24160:e=>{e.exports={"1.js":"let numbers = [];\r\nlet first = numbers.asEnumerable().firstOrDefault(0);\r\nconsole.log(first);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 0\r\n */","2.js":'let names = [ "Hartono, Tommy", "Adams, Terry",\r\n    "Andersen, Henriette Thaulow",\r\n    "Hedlund, Magnus", "Ito, Shu" ];\r\n\r\nlet firstLongName = names.asEnumerable().firstOrDefault("", name => name.length > 20);\r\n\r\nconsole.log(`The first long name is ${ firstLongName }.`);\r\n\r\nlet firstVeryLongName = names.asEnumerable().firstOrDefault("", name => name.length > 30);\r\n\r\nconsole.log(`There is ${ firstVeryLongName === "" ? "not a" : "a" } name longer than 30 characters.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The first long name is \'Andersen, Henriette Thaulow\'.\r\n There is not a name longer than 30 characters.\r\n */'}},25024:e=>{e.exports={"1.js":'// Create a list of pets.\r\nlet pets = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 },\r\n    { name: "Daisy", age: 4 }\r\n];\r\n\r\n// Group the pets using Age as the key value\r\n// and selecting only the pet\'s Name for each value.\r\nlet query = pets.asEnumerable().groupBy(pet => pet.age, pet => pet.name);\r\n\r\n// Iterate over each IGrouping in the collection.\r\nfor (let petGroup of query) {\r\n    // Print the key value of the IGrouping.\r\n    console.log(petGroup.key);\r\n    // Iterate over each value in the\r\n    // IGrouping and print the value.\r\n    for (let name of petGroup)\r\n        console.log(`  ${ name }`);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 8\r\n   Barley\r\n 4\r\n   Boots\r\n   Daisy\r\n 1\r\n   Whiskers\r\n */',"2-2.1.19.js":'// Create a list of pets.\r\nlet petsList = [\r\n    { name: "Barley", age: 8.3 },\r\n    { name: "Boots", age: 4.9 },\r\n    { name: "Whiskers", age: 1.5 },\r\n    { name: "Daisy", age: 4.3 }\r\n];\r\n\r\n// Group Pet objects by the Math.Floor of their age.\r\n// Then project an anonymous type from each group\r\n// that consists of the key, the count of the group\'s\r\n// elements, and the minimum and maximum age in the group.\r\nlet query = petsList.asEnumerable().groupBy(\r\n    pet => Math.floor(pet.age),\r\n    pet => pet,\r\n    (age, pets) => ({\r\n        key: age,\r\n        count: pets.count(),\r\n        min: pets.min(pet => pet.age),\r\n        max: pets.max(pet => pet.age)\r\n    }));\r\n\r\n// Iterate over each anonymous type.\r\nfor (let result of query) {\r\n    console.log("\\nAge group: " + result.key);\r\n    console.log("Number of pets in this age group: " + result.count);\r\n    console.log("Minimum age: " + result.min);\r\n    console.log("Maximum age: " + result.max);\r\n}\r\n\r\n/*  This code produces the following output:\r\n\r\n Age group: 8\r\n Number of pets in this age group: 1\r\n Minimum age: 8.3\r\n Maximum age: 8.3\r\n\r\n Age group: 4\r\n Number of pets in this age group: 2\r\n Minimum age: 4.3\r\n Maximum age: 4.9\r\n\r\n Age group: 1\r\n Number of pets in this age group: 1\r\n Minimum age: 1.5\r\n Maximum age: 1.5\r\n */',"2.js":'// Create a list of pets.\r\nlet petsList = [\r\n    { name: "Barley", age: 8.3 },\r\n    { name: "Boots", age: 4.9 },\r\n    { name: "Whiskers", age: 1.5 },\r\n    { name: "Daisy", age: 4.3 }\r\n];\r\n\r\n// Group Pet objects by the Math.Floor of their age.\r\n// Then project an anonymous type from each group\r\n// that consists of the key, the count of the group\'s elements.\r\nlet query = petsList.asEnumerable().groupBy(\r\n    pet => Math.floor(pet.age),\r\n    pet => pet,\r\n    (age, pets) => ({\r\n        key: age,\r\n        count: pets.count()\r\n    }));\r\n\r\n// Iterate over each anonymous type.\r\nfor (let result of query) {\r\n    console.log("\\nAge group: " + result.key);\r\n    console.log("Number of pets in this age group: " + result.count);\r\n}\r\n\r\n/*  This code produces the following output:\r\n\r\n Age group: 8\r\n Number of pets in this age group: 1\r\n\r\n Age group: 4\r\n Number of pets in this age group: 2\r\n\r\n Age group: 1\r\n Number of pets in this age group: 1\r\n */',"3-2.1.19.js":'// Create a list of pets.\r\nlet petsList = [\r\n    { name: "Barley", age: 8.3 },\r\n    { name: "Boots", age: 4.9 },\r\n    { name: "Whiskers", age: 1.5 },\r\n    { name: "Daisy", age: 4.3 }\r\n];\r\n\r\n// Group Pet objects by the Math.Floor of their age.\r\n// Then project an anonymous type from each group\r\n// that consists of the key, the count of the group\'s\r\n// elements, and the minimum and maximum age in the group.\r\nlet query = petsList.asEnumerable().groupBy(\r\n    pet => Math.floor(pet.age),\r\n    pet => pet.age,\r\n    (age, ages) => ({\r\n        key: age,\r\n        count: ages.count(),\r\n        min: ages.min(),\r\n        max: ages.max()\r\n    }));\r\n\r\n// Iterate over each anonymous type.\r\nfor (let result of query) {\r\n    console.log("\\nAge group: " + result.key);\r\n    console.log("Number of pets in this age group: " + result.count);\r\n    console.log("Minimum age: " + result.min);\r\n    console.log("Maximum age: " + result.max);\r\n}\r\n\r\n/*  This code produces the following output:\r\n\r\n Age group: 8\r\n Number of pets in this age group: 1\r\n Minimum age: 8.3\r\n Maximum age: 8.3\r\n\r\n Age group: 4\r\n Number of pets in this age group: 2\r\n Minimum age: 4.3\r\n Maximum age: 4.9\r\n\r\n Age group: 1\r\n Number of pets in this age group: 1\r\n Minimum age: 1.5\r\n Maximum age: 1.5\r\n */',"3.js":'// Create a list of pets.\r\nlet petsList = [\r\n    { name: "Barley", age: 8.3 },\r\n    { name: "Boots", age: 4.9 },\r\n    { name: "Whiskers", age: 1.5 },\r\n    { name: "Daisy", age: 4.3 }\r\n];\r\n\r\n// Group Pet objects by the Math.Floor of their age.\r\n// Then project an anonymous type from each group\r\n// that consists of the key, the count of the group\'s\r\n// elements, and the minimum and maximum age in the group.\r\nlet query = petsList.asEnumerable().groupBy(\r\n    pet => Math.floor(pet.age),\r\n    pet => pet.age,\r\n    (age, ages) => ({\r\n        key: age,\r\n        count: ages.count()\r\n    }));\r\n\r\n// Iterate over each anonymous type.\r\nfor (let result of query) {\r\n    console.log("\\nAge group: " + result.key);\r\n    console.log("Number of pets in this age group: " + result.count)\r\n}\r\n\r\n/*  This code produces the following output:\r\n\r\n Age group: 8\r\n Number of pets in this age group: 1\r\n\r\n Age group: 4\r\n Number of pets in this age group: 2\r\n\r\n Age group: 1\r\n Number of pets in this age group: 1\r\n */'}},55556:e=>{e.exports={"1.js":'let magnus = { name: "Hedlund, Magnus" };\r\nlet terry = { name: "Adams, Terry" };\r\nlet charlotte = { name: "Weiss, Charlotte" };\r\n\r\nlet barley = { name: "Barley", owner: terry };\r\nlet boots = { name: "Boots", owner: terry };\r\nlet whiskers = { name: "Whiskers", owner: charlotte };\r\nlet daisy = { name: "Daisy", owner: magnus };\r\n\r\nlet people = [ magnus, terry, charlotte ];\r\nlet pets = [ barley, boots, whiskers, daisy ];\r\n\r\n// Create a list where each element is an anonymous\r\n// type that contains a person\'s name and\r\n// a collection of names of the pets they own.\r\nlet query = people.asEnumerable().groupJoin(pets,\r\n    (person, petCollection) => ({\r\n        ownerName: person.name,\r\n        pets: petCollection.select(pet => pet.name)\r\n    }),\r\n    person => person,\r\n    pet => pet.owner);\r\n\r\nfor (let obj of query) {\r\n    // Output the owner\'s name.\r\n    console.log(`${ obj.ownerName }:`);\r\n    // Output each of the owner\'s pet\'s names.\r\n    for (let pet of obj.pets) {\r\n        console.log(`  ${ pet }`);\r\n    }\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Hedlund, Magnus:\r\n   Daisy\r\n Adams, Terry:\r\n   Barley\r\n   Boots\r\n Weiss, Charlotte:\r\n   Whiskers\r\n */'}},31683:e=>{e.exports={"1.js":"let id1 = [ 44, 26, 92, 30, 71, 38 ];\r\nlet id2 = [ 39, 59, 83, 47, 26, 4, 30 ];\r\n\r\nlet both = id1.asEnumerable().intersect(id2);\r\n\r\nfor (let id of both) {\r\n    console.log(id);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 26\r\n 30\r\n */","2.js":'// Custom comparer for distinct\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // Check whether the products\' properties are equal.\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet store1 = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 }\r\n];\r\nlet store2 = [\r\n    { name: "apple", code: 9 },\r\n    { name: "lemon", code: 12 }\r\n];\r\n\r\n// Get the products from the first array\r\n// that have duplicates in the second array.\r\nlet duplicates = store1.asEnumerable().intersect(store2, productComparer);\r\n\r\nfor (let product of duplicates) {\r\n    console.log(product.name + " " + product.code);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n apple 9\r\n */'}},63867:e=>{e.exports={"1.1.js":'let magnus = { name: "Hedlund, Magnus" };\r\nlet terry = { name: "Adams, Terry" };\r\nlet charlotte = { name: "Weiss, Charlotte" };\r\n\r\nlet barley = { name: "Barley", owner: terry };\r\nlet boots = { name: "Boots", owner: terry };\r\nlet whiskers = { name: "Whiskers", owner: charlotte };\r\nlet daisy = { name: "Daisy", owner: magnus };\r\n\r\nlet people = [ magnus, terry, charlotte ];\r\nlet pets = [ barley, boots, whiskers, daisy ];\r\n\r\n// Create a list of Person-Pet pairs where\r\n// each element is an anonymous type that contains a\r\n// Pet\'s name and the name of the Person that owns the Pet.\r\nlet query = people.asEnumerable().join(pets,\r\n    (person, pet) => ({ ownerName: person.name, pet: pet.name }),\r\n    person => person,\r\n    pet => pet.owner);\r\n\r\nfor (let obj of query) {\r\n    console.log(`${ obj.ownerName } - ${ obj.pet }`);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Hedlund, Magnus - Daisy\r\n Adams, Terry - Barley\r\n Adams, Terry - Boots\r\n Weiss, Charlotte - Whiskers\r\n */'}},27065:e=>{e.exports={"1.js":"let longs = [ 4294967296, 466855135, 81125 ];\r\n\r\nlet max = longs.asEnumerable().max();\r\n\r\nconsole.log(`The largest number is ${ max }.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The largest number is 4294967296.\r\n */","2.js":'let pets = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 }\r\n];\r\n\r\nlet max = pets.asEnumerable().max(pet => pet.age + pet.name.length);\r\n\r\nconsole.log(`The maximum pet age plus name length is ${ max }.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The maximum pet age plus name length is 14.\r\n */'}},81622:e=>{e.exports={"1.js":"let longs = [ 4294967296, 466855135, 81125 ];\r\n\r\nlet min = longs.asEnumerable().min();\r\n\r\nconsole.log(`The smallest number is ${ min }.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The smallest number is 81125.\r\n */","2.js":'let pets = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 }\r\n];\r\n\r\nlet min = pets.asEnumerable().min(pet => pet.age);\r\n\r\nconsole.log(`The youngest animal is age ${ min }.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The youngest animal is age 5.\r\n */'}},45849:e=>{e.exports={"1-2.1.19.js":'let fruits = ["Mango", "Orange", "Apple", 3.0, "Banana"];\r\n\r\n// Apply ofType() to the Array\r\nlet query1 = fruits.asEnumerable().ofType(String);\r\n\r\nconsole.log("Elements of type \'String\' are:");\r\nfor (let fruit of query1) {\r\n    console.log(fruit);\r\n}\r\n\r\n// The following query shows that the standard query operators such as\r\n// where() can be applied to the Array type after calling ofType().\r\nlet query2 = fruits.asEnumerable().ofType(String).where(fruit => fruit.asEnumerable().contains("n", Enumerable.comparers.ignoreCase()));\r\n\r\nconsole.log("\\nThe following strings contain \'n\':");\r\nfor (let fruit of query2) {\r\n    console.log(fruit);\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// Elements of type \'string\' are:\r\n// Mango\r\n// Orange\r\n// Apple\r\n// Banana\r\n//\r\n// The following strings contain \'n\':\r\n// Mango\r\n// Orange\r\n// Banana',"1.js":'let fruits = ["Mango", "Orange", "Apple", 3.0, "Banana"];\r\n\r\n// Apply ofType() to the Array\r\nlet query1 = fruits.asEnumerable().ofType(String);\r\n\r\nconsole.log("Elements of type \'String\' are:");\r\nfor (let fruit of query1) {\r\n    console.log(fruit);\r\n}\r\n\r\n// The following query shows that the standard query operators such as\r\n// where() can be applied to the Array type after calling ofType().\r\nlet query2 = fruits.asEnumerable().ofType(String).where(fruit => fruit.toLowerCase().asEnumerable().contains("n"));\r\n\r\nconsole.log("\\nThe following strings contain \'n\':");\r\nfor (let fruit of query2) {\r\n    console.log(fruit);\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// Elements of type \'string\' are:\r\n// Mango\r\n// Orange\r\n// Apple\r\n// Banana\r\n//\r\n// The following strings contain \'n\':\r\n// Mango\r\n// Orange\r\n// Banana'}},93101:e=>{e.exports={"1.js":'let pets = [\r\n    { name: "Barley", age: 8 },\r\n    { name: "Boots", age: 4 },\r\n    { name: "Whiskers", age: 1 }\r\n];\r\n\r\nlet query = pets.asEnumerable().orderBy(pet => pet.age);\r\n\r\nfor (let pet of query) {\r\n    console.log(`${ pet.name } - ${ pet.age }`);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Whiskers - 1\r\n Boots - 4\r\n Barley - 8\r\n*/'}},80098:e=>{e.exports={"1.js":"const specialComparer = (d1, d2) => {\r\n    let f1 = d1 * 1e16 % 1e16 / 1e16;\r\n    let f2 = d2 * 1e16 % 1e16 / 1e16;\r\n    if (f1 === f2) {\r\n        return d1 - d2;\r\n    } else if (f1 > f2) {\r\n        return 1;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\nlet decimals = [ 6.2, 8.3, 0.5, 1.3, 6.3, 9.7 ];\r\n\r\nlet query = decimals.asEnumerable().orderByDescending(num => num, specialComparer);\r\n\r\nfor (let num of query) {\r\n    console.log(num);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 9.7\r\n 0.5\r\n 8.3\r\n 6.3\r\n 1.3\r\n 6.2\r\n*/"}},46805:e=>{e.exports={"1.js":"let squares = Enumerable.range(1, 10).select(x => x * x);\r\n\r\nfor (let num of squares) {\r\n    console.log(num);\r\n}\r\n/*\r\n This code produces the following output:\r\n\r\n 1\r\n 4\r\n 9\r\n 16\r\n 25\r\n 36\r\n 49\r\n 64\r\n 81\r\n 100\r\n*/","2.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet query = fruits.asEnumerable().select((fruit, index) => ({ index, str: fruit.substring(0, index) }));\r\n\r\nfor (let obj of query) {\r\n    console.log(obj);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n {"index":0,"str":""}\r\n {"index":1,"str":"b"}\r\n {"index":2,"str":"ma"}\r\n {"index":3,"str":"ora"}\r\n {"index":4,"str":"pass"}\r\n {"index":5,"str":"grape"}\r\n*/'}},16536:e=>{e.exports={"1.js":'let petOwners = [\r\n    { name: "Higa, Sidney", pets: [ "Scruffy", "Sam" ] },\r\n    { name: "Ashkenazi, Ronen", pets: [ "Walker", "Sugar" ] },\r\n    { name: "Price, Vernette", pets: [ "Scratches", "Diesel" ] }\r\n];\r\n\r\n// Query using selectMany().\r\nlet query1 = petOwners.asEnumerable().selectMany(petOwner => petOwner.pets);\r\n\r\nconsole.log("Using selectMany():");\r\n\r\n// Only one foreach loop is required to iterate\r\n// through the results since it is a\r\n// one-dimensional collection.\r\nfor (let pet of query1) {\r\n    console.log(pet);\r\n}\r\n\r\n// This code shows how to use select()\r\n// instead of selectMany().\r\nlet query2 = petOwners.asEnumerable().select(petOwner => petOwner.pets);\r\n\r\nconsole.log("\\nUsing select():");\r\n\r\n// Notice that two foreach loops are required to\r\n// iterate through the results\r\n// because the query returns a collection of arrays.\r\nfor (let petList of query2) {\r\n    for (let pet of petList) {\r\n        console.log(pet);\r\n    }\r\n    console.log();\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Using selectMany():\r\n Scruffy\r\n Sam\r\n Walker\r\n Sugar\r\n Scratches\r\n Diesel\r\n\r\n Using select():\r\n Scruffy\r\n Sam\r\n\r\n Walker\r\n Sugar\r\n\r\n Scratches\r\n Diesel\r\n\r\n*/',"2.js":'let petOwners = [\r\n    { name: "Higa, Sidney", pets: [ "Scruffy", "Sam" ] },\r\n    { name: "Ashkenazi, Ronen", pets: [ "Walker", "Sugar" ] },\r\n    { name: "Price, Vernette", pets: [ "Scratches", "Diesel" ] },\r\n    { name: "Hines, Patrick", pets: [ "Dusty" ] }\r\n];\r\n\r\n// Project the items in the array by appending the index\r\n// of each PetOwner to each pet\'s name in that petOwner\'s\r\n// array of pets.\r\nlet query = petOwners.asEnumerable().selectMany((petOwner, index) =>\r\n        petOwner.pets.asEnumerable().select(pet => index + pet));\r\n\r\nfor (let pet of query) {\r\n    console.log(pet);\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// 0Scruffy\r\n// 0Sam\r\n// 1Walker\r\n// 1Sugar\r\n// 2Scratches\r\n// 2Diesel\r\n// 3Dusty',"3.js":'let petOwners = [\r\n    { name: "Higa, Sidney", pets: [ "Scruffy", "Sam" ] },\r\n    { name: "Ashkenazi, Ronen", pets: [ "Walker", "Sugar" ] },\r\n    { name: "Price, Vernette", pets: [ "Scratches", "Diesel" ] },\r\n    { name: "Hines, Patrick", pets: [ "Dusty" ] }\r\n];\r\n\r\n// Project the pet owner\'s name and the pet\'s name.\r\nlet query = petOwners.asEnumerable().selectMany(petOwner => petOwner.pets, (petOwner, petName) => ({ petOwner, petName }))\r\n        .where(ownerAndPet => ownerAndPet.petName.startsWith("S"))\r\n        .select(ownerAndPet => ({\r\n            owner: ownerAndPet.petOwner.name,\r\n            pet: ownerAndPet.petName\r\n        }));\r\n\r\n// Print the results.\r\nfor (let obj of query) {\r\n    console.log(obj);\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// {"owner":"Higa","pet":"Scruffy"}\r\n// {"owner":"Higa","pet":"Sam"}\r\n// {"owner":"Ashkenazi","pet":"Sugar"}\r\n// {"owner":"Price","pet":"Scratches"}'}},42569:e=>{e.exports={"1.js":'let pet1 = { name: "Turbo", age: 2 };\r\nlet pet2 = { name: "Peanut", age: 8 };\r\n\r\n// Create two lists of pets.\r\nlet pets1 = [ pet1, pet2 ];\r\nlet pets2 = [ pet1, pet2 ];\r\n\r\nlet equal = pets1.asEnumerable().sequenceEqual(pets2);\r\n\r\nconsole.log(`The lists ${ equal ? "are" : "are not" } equal.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The lists are equal.\r\n*/',"2.js":'// 一个自定义的比较器。\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // 如果产品的名称和数目相等，则表示是相同的产品。\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet storeA = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 }\r\n];\r\n\r\nlet storeB = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 }\r\n];\r\n\r\nlet equalAB = storeA.asEnumerable().sequenceEqual(storeB, productComparer);\r\n\r\nconsole.log("Equal? " + equalAB);\r\n\r\n/*\r\n    This code produces the following output:\r\n\r\n    Equal? True\r\n*/'}},3087:e=>{e.exports={"1.js":'let fruits1 = [ "orange" ];\r\n\r\nlet fruit1 = fruits1.asEnumerable().single();\r\n\r\nconsole.log(fruit1);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n orange\r\n*/',"2.js":'let fruits2 = [ "orange", "apple" ];\r\nlet fruit2 = null;\r\n\r\ntry {\r\n    fruit2 = fruits2.asEnumerable().single();\r\n    console.log(fruit2);\r\n} catch (e) {\r\n    console.log("The collection does not contain exactly one element.");\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The collection does not contain exactly one element.\r\n*/\r\n',"3.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet fruit1 = fruits.asEnumerable().single(fruit => fruit.length > 10);\r\n\r\nconsole.log(fruit1);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n passionfruit\r\n*/',"4.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\nlet fruit2 = null;\r\n\r\ntry {\r\n    fruit2 = fruits.asEnumerable().single(fruit => fruit.length > 15);\r\n\r\n    console.log(fruit2);\r\n} catch (e) {\r\n    console.log("The collection does not contain exactly one element whose length is greater than 15.");\r\n}\r\n\r\n// This code produces the following output:\r\n//\r\n// The collection does not contain exactly one element whose length is greater than 15.'}},9249:e=>{e.exports={"1.js":'let fruits1 = [ "orange" ];\r\n\r\nlet fruit1 = fruits1.asEnumerable().singleOrDefault("No such string!");\r\n\r\nconsole.log(fruit1);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n orange\r\n*/',"2.js":'let fruits2 = [];\r\n\r\nlet fruit2 = fruits2.asEnumerable().singleOrDefault("No such string!");\r\n\r\nconsole.log(fruit2);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n No such string!\r\n*/',"3.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet fruit1 = fruits.asEnumerable().singleOrDefault("No such string!", fruit => fruit.length > 10);\r\n\r\nconsole.log(fruit1);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n passionfruit\r\n*/',"4.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet fruit2 = fruits.asEnumerable().singleOrDefault("No such string!", fruit => fruit.length > 15);\r\n\r\nconsole.log(fruit2);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n No such string!\r\n*/'}},3961:e=>{e.exports={"1.js":'let grades = [ 59, 82, 70, 56, 92, 98, 85 ];\r\n\r\nlet lowerGrades = grades.asEnumerable().orderByDescending(g => g).skip(3);\r\n\r\nconsole.log("All grades except the top three are:");\r\nfor (let grade of lowerGrades) {\r\n    console.log(grade);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n All grades except the top three are:\r\n 82\r\n 70\r\n 59\r\n 56\r\n*/'}},28613:e=>{e.exports={"1.js":'let grades = [ 59, 82, 70, 56, 92, 98, 85 ];\r\n\r\nlet lowerGrades = grades.asEnumerable().orderByDescending().skipWhile(grade => grade >= 80);\r\n\r\nconsole.log("All grades below 80:");\r\nfor (let grade of lowerGrades) {\r\n    console.log(grade);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n All grades below 80:\r\n 70\r\n 59\r\n 56\r\n*/',"2.js":"let amounts = [ 5000, 2500, 9000, 8000, 6500, 4000, 1500, 5500 ];\r\n\r\nlet query = amounts.asEnumerable().skipWhile((amount, index) => amount > index * 1000);\r\n\r\nfor (let amount of query) {\r\n    console.log(amount);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 4000\r\n 1500\r\n 5500\r\n*/"}},78846:e=>{e.exports={"1.js":"let numbers = [ 43.68, 1.25, 583.7, 6.5 ];\r\n\r\nlet sum = numbers.asEnumerable().sum();\r\n\r\nconsole.log(`The sum of the numbers is ${ sum }.`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The sum of the numbers is 635.13.\r\n*/","2.js":'let packages = [\r\n    { company: "Coho Vineyard", weight: 25.2 },\r\n    { company: "Lucerne Publishing", weight: 18.7 },\r\n    { company: "Wingtip Toys", weight: 6.0 },\r\n    { company: "Adventure Works", weight: 33.9 }\r\n];\r\n\r\nlet totalWeight = packages.asEnumerable().sum(pkg => pkg.weight);\r\n\r\nconsole.log(`The total weight of the packages is: ${ totalWeight }`);\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The total weight of the packages is: 83.8\r\n*/'}},84570:e=>{e.exports={"1.js":'let grades = [ 59, 82, 70, 56, 92, 98, 85 ];\r\n\r\nlet topThreeGrades = grades.asEnumerable().orderByDescending().take(3);\r\n\r\nconsole.log("The top three grades are:");\r\nfor (let grade of topThreeGrades) {\r\n    console.log(grade);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n The top three grades are:\r\n 98\r\n 92\r\n 85\r\n*/'}},55190:e=>{e.exports={"1.js":'let fruits = [ "apple", "banana", "mango", "orange", "passionfruit", "grape" ];\r\n\r\nlet query = fruits.asEnumerable().takeWhile(fruit => "orange" !== fruit);\r\n\r\nfor (let fruit of query) {\r\n    console.log(fruit);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n apple\r\n banana\r\n mango\r\n*/',"2.js":'let fruits = [ "apple", "passionfruit", "banana", "mango", "orange", "blueberry", "grape", "strawberry" ];\r\n\r\nlet query = fruits.asEnumerable().takeWhile((fruit, index) => fruit.length >= index);\r\n\r\nfor (let fruit of query) {\r\n    console.log(fruit);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n apple\r\n passionfruit\r\n banana\r\n mango\r\n orange\r\n blueberry\r\n*/'}},87941:e=>{e.exports={"1.js":"let ints1 = [ 5, 3, 9, 7, 5, 9, 3, 7 ];\r\nlet ints2 = [ 8, 3, 6, 4, 4, 9, 1, 0 ];\r\n\r\nlet union = ints1.asEnumerable().union(ints2);\r\n\r\nfor (let num of union) {\r\n    console.log(num);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 5\r\n 3\r\n 9\r\n 7\r\n 8\r\n 6\r\n 4\r\n 1\r\n 0\r\n*/","2.js":'// 一个自定义的比较器。\r\nlet productComparer = (x, y) => {\r\n    if (x === y) return true;\r\n    if (!x || !y) return false;\r\n    // 如果产品的名称和编号相等，则表示是相同的产品。\r\n    return x.code === y.code && x.name === y.name;\r\n};\r\n\r\nlet store1 = [\r\n    { name: "apple", code: 9 },\r\n    { name: "orange", code: 4 }\r\n];\r\n\r\nlet store2 = [\r\n    { name: "apple", code: 9 },\r\n    { name: "lemon", code: 12 }\r\n];\r\n\r\n//Get the products from the both arrays\r\n//excluding duplicates.\r\nlet union = store1.asEnumerable().union(store2, productComparer);\r\n\r\nfor (let product of union) {\r\n    console.log(product.name + " " + product.code);\r\n}\r\n\r\n/*\r\n    This code produces the following output:\r\n\r\n    apple 9\r\n    orange 4\r\n    lemon 12\r\n*/'}},47067:e=>{e.exports={"1.js":'let fruits = [ "apple", "passionfruit", "banana", "mango", "orange", "blueberry", "grape", "strawberry" ];\r\n\r\nlet query = fruits.asEnumerable().where(fruit => fruit.length < 6);\r\n\r\nfor (let fruit of query) {\r\n    console.log(fruit);\r\n}\r\n/*\r\n This code produces the following output:\r\n\r\n apple\r\n mango\r\n grape\r\n*/',"2.js":"let numbers = [ 0, 30, 20, 15, 90, 85, 40, 75 ];\r\n\r\nlet query = numbers.asEnumerable().where((number, index) => number <= index * 10);\r\n\r\nfor (let number of query) {\r\n    console.log(number);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n 0\r\n 20\r\n 15\r\n 40\r\n*/"}},33808:e=>{e.exports={"1.js":'let numbers = [ 1, 2, 3, 4 ];\r\nlet words = [ "one", "two", "three" ];\r\n\r\nlet numbersAndWords = numbers.asEnumerable().zip(words, (first, second) => first + " " + second);\r\n\r\nfor (let item of numbersAndWords) {\r\n    console.log(item);\r\n}\r\n\r\n// This code produces the following output:\r\n\r\n// 1 one\r\n// 2 two\r\n// 3 three'}},14285:e=>{e.exports={"config.as.js":"Enumerable.config.as = 'em';\r\nlet enumerable = [1, 2, 3].em();","config.extends.js":"Enumerable.config.extends.array = true; //Open extends for Array. After open this, Array will have all the features of LINQ and you can use methods of LINQ for Array. (Suggest)\r\nEnumerable.config.extends.string = true; //Open extends for String. After open this, String will have all the features of LINQ and you can use methods of LINQ for String.(Not suggest)\r\nEnumerable.config.extends.object = true; //Open extends for Object. After open this, each object will have all the features of LINQ and you can use methods of LINQ for every object.(Not suggest)"}},80846:e=>{e.exports={"asEnumerable.js":"let a = [1, 2, 3].asEnumerable();\r\nlet o = ({ key: 1, value: 'a' }).asEnumerable();\r\nlet s = 'abc'.asEnumerable();","Enumerable.asEnumerable.js":"let enumerable = Enumerable.asEnumerable([1, 2, 3]);","Enumerable.js":"let enumerable = Enumerable([1, 2, 3]);"}},67632:e=>{e.exports={"1.js":'let pets = [\r\n    { name: "Barley", props: { age: 10, weight: 59 } },\r\n    { name: "Boots", props: { age: 14, weight: 50 } },\r\n    { name: "Whiskers", props: { age: 6, weight: 36 } }\r\n];\r\n\r\npets.asEnumerable().select("name");\r\n//the above code and the following code are same feature.\r\npets.asEnumerable().select(pet => pet.name);',"1.try.js":'let pets = [\r\n    { name: "Barley", props: { age: 10, weight: 59 } },\r\n    { name: "Boots", props: { age: 14, weight: 50 } },\r\n    { name: "Whiskers", props: { age: 6, weight: 36 } }\r\n];\r\n\r\nconsole.log(pets.asEnumerable().select("name"));\r\n//the above code and the following code are same feature.\r\nconsole.log(pets.asEnumerable().select(pet => pet.name));',"2.js":"let arrays = [\r\n    [ 1, 2, 4, 8 ],\r\n    [ 1, 3, 9 ],\r\n    [ 1, 5 ]\r\n];\r\n\r\narrays.asEnumerable().select(1);\r\n//the above code and the following code are same feature.\r\narrays.asEnumerable().select(array => array[1]);"}},79741:e=>{e.exports={"1.js":'let pets = [ { name: "Barley", age: 8, vaccinated: true }, { name: "Boots", age: 4, vaccinated: false }, { name: "Whiskers", age: 1, vaccinated: false } ];\r\n\r\nlet unvaccinated = pets.asEnumerable().any(p => p.age > 1 && p.vaccinated === false);\r\n\r\nconsole.log(`There ${ unvaccinated ? "are" : "are not any" } unvaccinated animals over age one.`);\r\n\r\n// This code produces the following output:\r\n//\r\n//  There are unvaccinated animals over age one.',"2.js":'let magnus = { name: "Hedlund, Magnus" }, terry = { name: "Adams, Terry" }, charlotte = { name: "Weiss, Charlotte" };\r\nlet barley = { name: "Barley", owner: terry }, boots = { name: "Boots", owner: terry }, whiskers = { name: "Whiskers", owner: charlotte }, daisy = { name: "Daisy", owner: magnus };\r\nlet people = [ magnus, terry, charlotte ];\r\nlet pets = [ barley, boots, whiskers, daisy ];\r\n\r\nlet query = people.asEnumerable().join(pets,\r\n    (person, pet) => ({ ownerName: person.name, pet: pet.name }),\r\n    person => person,\r\n    pet => pet.owner);\r\n\r\nfor (let obj of query) {\r\n    console.log(`${ obj.ownerName } - ${ obj.pet }`);\r\n}\r\n\r\n/*\r\n This code produces the following output:\r\n\r\n Hedlund, Magnus - Daisy\r\n Adams, Terry - Barley\r\n Adams, Terry - Boots\r\n Weiss, Charlotte - Whiskers\r\n */'}},80925:e=>{e.exports={title:"Action",contents:[{title:"What's the Action",descriptions:[{content:"Action is a function which is only execute some calculation for the parameters"},{content:"The Action function accept one parameter, or accept another parameter which is the index of the first parameter in the enumerable as the second parameter, then execute some calculation but return nothing"},{}]}]}},26854:e=>{e.exports={title:"Comparer"}},38471:e=>{e.exports={title:"Configuration"}},53226:e=>{e.exports={title:"Get IEnumerable instance",contents:[{title:"Use constructor of Enumerable class",descriptions:[{content:"You can use constructor of Enumerable class for get an IEnumerable object"}]},{title:"Use Enumerable.asEnumerable method"},{title:"Use asEnumerable method",descriptions:[{content:"After require linq-js, asEnumerable method war included by any object, you can use asEnumerable of any object for get an IEnumerable object"}]}]}},32948:e=>{e.exports={title:"Predicate"}},33193:e=>{e.exports={title:"Selector",contents:[{title:"What's the Selector",descriptions:[{content:"The Selector is a function which mapping an input value to an output value."},{content:"The function accept one or more arguments, sometimes, it also accept index of the collection as argument."}]},{title:"Unary Selector"},{title:"Binary Selector"},{title:"Use string/number/symbol value to replace the Selector",descriptions:[{content:"You can use a string or a number or a symbol value to replace an Unary Selector, the examples following will show you how to use string or number value to replace the Selector"}]}]}},63996:e=>{e.exports={title:"Start use"}},31836:e=>{e.exports={title:"Install",contents:[{title:"Add to project"},{title:"Require",details:[{remarks:["description:This module require ES6. I suggest you to use this with ES6. The following examples is already use ES6."]}]}]}},27775:e=>{e.exports={title:"Introduction",contents:["use linq and lambda in javascript for es6","&nbsp;","","Since 2.1.0, I rewrite all to use new features of ES6. The performance be better, memory is used less and using deferred execution.","&nbsp;","My English is poor!"]}},81326:e=>{e.exports={name:"English"}}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2FwaXMvRW51bWVyYWJsZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvYXBpcy9FbnVtZXJhYmxlL21ldGEuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2FwaXMvRW51bWVyYWJsZS9tZXRob2RzL2FzRW51bWVyYWJsZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvYXBpcy9FbnVtZXJhYmxlL21ldGhvZHMvZW1wdHkuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2FwaXMvRW51bWVyYWJsZS9wcm9wZXJ0aWVzL2FjdGlvbnMuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2FwaXMvRW51bWVyYWJsZS9wcm9wZXJ0aWVzL2NvbXBhcmVycy5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvYXBpcy9FbnVtZXJhYmxlL3Byb3BlcnRpZXMvY29uZmlnLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9hcGlzL0VudW1lcmFibGUvcHJvcGVydGllcy9wcmVkaWNhdGVzLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9hcGlzL0VudW1lcmFibGUvcHJvcGVydGllcy9zZWxlY3RvcnMuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2NhcHRpb24uanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2NoYW5nZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZGlyZWN0b3J5Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9kaXJlY3RvcnkubWV0YS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvYWdncmVnYXRlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL2FsbC5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9hbnkuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvYXZlcmFnZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9jb25jYXQuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvY29udGFpbnMuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvY291bnQuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZGVmYXVsdElmRW1wdHkuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZGlzdGluY3QuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZWxlbWVudEF0Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL2VsZW1lbnRBdE9yRGVmYXVsdC5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9leGNlcHQuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZmlyc3QuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZmlyc3RPckRlZmF1bHQuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvZ3JvdXBCeS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9ncm91cEpvaW4uanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvaW50ZXJzZWN0Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL2pvaW4uanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvbWF4Lmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL21pbi5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9vZlR5cGUuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvb3JkZXJCeS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9vcmRlckJ5RGVzY2VuZGluZy5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9zZWxlY3QuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvc2VsZWN0TWFueS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9zZXF1ZW5jZUVxdWFsLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL3NpbmdsZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9zaW5nbGVPckRlZmF1bHQuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvc2tpcC5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvSUVudW1lcmFibGUvbWV0aG9kcy9za2lwV2hpbGUuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvc3VtLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL3Rha2UuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL0lFbnVtZXJhYmxlL21ldGhvZHMvdGFrZVdoaWxlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL3VuaW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL3doZXJlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9JRW51bWVyYWJsZS9tZXRob2RzL3ppcC5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvY29uZmlnLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9leGFtcGxlcy9pbnN0YW5jZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZXhhbXBsZXMvc2VsZWN0b3IuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2V4YW1wbGVzL3VzZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZ3VpZGVzL2FjdGlvbi5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZ3VpZGVzL2NvbXBhcmVyLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9ndWlkZXMvY29uZmlnLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9ndWlkZXMvaW5zdGFuY2UuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2d1aWRlcy9wcmVkaWNhdGUuanNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVzb3VyY2VzL2VuLXVzL2d1aWRlcy9zZWxlY3Rvci5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvZ3VpZGVzL3VzZS5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvaW5zdGFsbC5qc29uIiwid2VicGFjazovLy8uL3NyYy9yZXNvdXJjZXMvZW4tdXMvaW50cm9kdWN0aW9uLmpzb24iLCJ3ZWJwYWNrOi8vLy4vc3JjL3Jlc291cmNlcy9lbi11cy9tZXRhLmpzb24iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImNvbnN0cnVjdG9ycyIsImhpc3RvcnlzIiwib3ZlcmxvYWRzIiwiZGVzY3JpcHRpb24iLCJuYW1lIiwicHJvcGVydGllcyIsImRlcHJlY2F0ZWQiLCJtZXRob2RzIiwiY2xhc3MiLCJpbnRlcmZhY2UiLCJvYmplY3QiLCJjb25zdHJ1Y3RvciIsInByb3BlcnR5IiwibWV0aG9kIiwic2luY2UiLCJkZXRhaWxzIiwic3VtbWFyeSIsIndhcm5pbmciLCJ3YXJuaW5ncyIsInJlbWFyayIsInJlbWFya3MiLCJleGFtcGxlIiwiZXhhbXBsZXMiLCJzdGF0aWMiLCJuZXciLCJzZWUiLCJkZWNsYXJlIiwicGFyYW1ldGVycyIsInBhcmFtZXRlciIsInJldHVybnMiLCJnZW5lcmljcyIsImFwaXMiLCJndWlkZSIsInB1Ymxpc2giLCJ0aW1lIiwiZGF0ZSIsInByZXB1Ymxpc2giLCJ2ZXJzaW9uIiwiYXV0aG9yIiwiZW1haWwiLCJwcm9qZWN0IiwiZGVmYXVsdCIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwicmVhZG9ubHkiLCJsYXp5IiwidHJ5IiwicnVuIiwiY2xlYXIiLCJjbG9zZSIsImxvYWRSdW50aW1lIiwiZXhlY3V0aW5nIiwiZW5hYmxlRXh0ZW5kIiwibmV3SW5zdGFuY2UiLCJvbmx5IiwiYm90aCIsImNhbm5vdCIsImNvbnRlbnRzIiwiY29kZSIsInRpdGxlIiwiY2hpbGRyZW4iLCJkZXNjcmlwdGlvbnMiLCJjb250ZW50Il0sIm1hcHBpbmdzIjoieUZBQUFBLEVBQU9DLFFBQVUsQ0FBQ0MsYUFBYSxDQUFDQyxTQUFTLENBQUMsQ0FBQ0MsVUFBVSxDQUFDLENBQUNDLFlBQVksd0RBQXdEQyxLQUFLLGFBQWFDLFdBQVcsQ0FBQyxDQUFDRCxLQUFLLFVBQVVILFNBQVMsQ0FBQyxDQUFDSyxXQUFXLEVBQUVILFlBQVksNENBQTRDLENBQUNDLEtBQUssWUFBWUgsU0FBUyxDQUFDLENBQUNLLFdBQVcsRUFBRUgsWUFBWSw4Q0FBOEMsQ0FBQ0MsS0FBSyxTQUFTSCxTQUFTLENBQUMsQ0FBQ0ssV0FBVyxFQUFFSCxZQUFZLG1CQUFtQixDQUFDQyxLQUFLLGFBQWFILFNBQVMsQ0FBQyxDQUFDSyxXQUFXLEVBQUVILFlBQVksK0NBQStDLENBQUNDLEtBQUssWUFBWUgsU0FBUyxDQUFDLENBQUNLLFdBQVcsRUFBRUgsWUFBWSwrQ0FBK0NJLFFBQVEsQ0FBQyxDQUFDSCxLQUFLLGVBQWVILFNBQVMsQ0FBQyxDQUFDSyxXQUFXLEVBQUVKLFVBQVUsQ0FBQyxDQUFDQyxZQUFZLHdEQUF3RCxDQUFDQyxLQUFLLFFBQVFILFNBQVMsQ0FBQyxDQUFDSyxXQUFXLEVBQUVKLFVBQVUsQ0FBQyxDQUFDQyxZQUFZLDZDLFVDQWx6QkwsRUFBT0MsUUFBVSxDQUFDQyxhQUFhLENBQUNDLFNBQVMsQ0FBQyxDQUFDQyxVQUFVLENBQUMsQ0FBQ0MsWUFBWSwwRCxVQ0FuRUwsRUFBT0MsUUFBVSxDQUFDRSxTQUFTLENBQUMsQ0FBQ0MsVUFBVSxDQUFDLENBQUNDLFlBQVkseUQsVUNBckRMLEVBQU9DLFFBQVUsQ0FBQ0UsU0FBUyxDQUFDLENBQUNDLFVBQVUsQ0FBQyxDQUFDQyxZQUFZLDJDLFVDQXJETCxFQUFPQyxRQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDRSxZQUFZLDZDLFVDQXpDTCxFQUFPQyxRQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDRSxZQUFZLCtDLFVDQXpDTCxFQUFPQyxRQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDRSxZQUFZLG9CLFVDQXpDTCxFQUFPQyxRQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDRSxZQUFZLGdELFVDQXpDTCxFQUFPQyxRQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDRSxZQUFZLCtDLFNDQXpDTCxFQUFPQyxRQUFVLENBQUNTLE1BQU0sUUFBUUMsVUFBVSxZQUFZQyxPQUFPLFNBQVNDLFlBQVksY0FBY1gsYUFBYSxlQUFlWSxTQUFTLFdBQVdQLFdBQVcsYUFBYVEsT0FBTyxTQUFTTixRQUFRLFVBQVVPLE1BQU0sUUFBUVIsV0FBVyxhQUFhUyxRQUFRLFVBQVVaLFlBQVksY0FBY2EsUUFBUSxVQUFVQyxRQUFRLFVBQVVDLFNBQVMsV0FBV0MsT0FBTyxTQUFTQyxRQUFRLFVBQVVDLFFBQVEsVUFBVUMsU0FBUyxXQUFXQyxPQUFPLFNBQVNDLElBQUksTUFBTUMsSUFBSSxNQUFNQyxRQUFRLFVBQVVDLFdBQVcsYUFBYUMsVUFBVSxZQUFZQyxRQUFRLGVBQWVDLFNBQVMsa0JBQWtCQyxLQUFLLE9BQU9DLE1BQU0sUUFBUUMsUUFBUSxVQUFVQyxLQUFLLE9BQU9DLEtBQUssT0FBT0MsV0FBVyxhQUFhQyxRQUFRLFVBQVVDLE9BQU8sU0FBU0MsTUFBTSxRQUFRQyxRQUFRLFVBQVVDLFFBQVEsVUFBVUMsTUFBTSxRQUFRQyxhQUFhLGdCQUFnQkMsU0FBUyxXQUFXQyxLQUFLLHFCQUFxQkMsSUFBSSxTQUFTQyxJQUFJLE1BQU1DLE1BQU0sUUFBUUMsTUFBTSxRQUFRQyxZQUFZLGtCQUFrQkMsVUFBVSxZQUFZQyxhQUFhLDBCQUEwQkMsWUFBWSxDQUFDQyxLQUFLLDRCQUE0QkMsS0FBSyw4QkFBOEJDLE9BQU8sOEIsU0NBamlDMUQsRUFBT0MsUUFBVSxDQUFDLENBQUNrQyxRQUFRLGFBQWF3QixTQUFTLENBQUMsWUFBWSwyQkFBMkIsK0NBQStDLG9GQUFvRiw4Q0FBOEMsaURBQWlELDRDQUE0QyxnREFBZ0QsMkdBQTJHcEIsUUFBUSxVQUFVLENBQUNKLFFBQVEsYUFBYXdCLFNBQVMsQ0FBQyxpSEFBaUgsMkhBQTJILHlFQUF5RSx5REFBeURwQixRQUFRLFVBQVUsQ0FBQ0osUUFBUSxhQUFhd0IsU0FBUyxDQUFDLGlCQUFpQixxQ0FBcUMsa0NBQWtDLG9EQUFvRCxxR0FBcUcsb0RBQW9EcEIsUUFBUSxVQUFVLENBQUNKLFFBQVEsYUFBYXdCLFNBQVMsQ0FBQyx5REFBeUQscUNBQXFDLGdFQUFnRSxpREFBaUQsNkZBQTZGLHFEQUFxRCwwQ0FBMEMsa0NBQWtDLHVDQUF1Qyw2Q0FBNkMsNENBQTRDLHFFQUFxRSxtQ0FBbUMsR0FBRyxPQUFPLDZDQUE2Q3BCLFFBQVEsVUFBVSxDQUFDSixRQUFRLGFBQWF3QixTQUFTLENBQUMsV0FBVyw0RUFBNEUseURBQXlELGdGQUFnRiw2Q0FBNkMsR0FBRyxvQkFBb0Isc0JBQXNCLDhEQUE4RCx3RkFBd0Ysc0pBQXNKLEdBQUcsYUFBYSx3REFBd0QsdUVBQXVFLDREQUE0RHBCLFFBQVEsVUFBVSxDQUFDSixRQUFRLGFBQWF3QixTQUFTLENBQUMsV0FBVyxnR0FBZ0csMERBQTBELDREQUE0RCwwQ0FBMEMsa0RBQWtELHdDQUF3Qyw0Q0FBNEMsNkZBQTZGLEdBQUcsb0JBQW9CLDBDQUEwQyw2QkFBNkIsR0FBRyxhQUFhLDJEQUEyRHBCLFFBQVEsVUFBVSxDQUFDSixRQUFRLGFBQWF3QixTQUFTLENBQUMsV0FBVyxzRkFBc0YsMERBQTBELEdBQUcsb0JBQW9CLGdFQUFnRSxHQUFHLGNBQWNwQixRQUFRLFVBQVUsQ0FBQ0osUUFBUSxhQUFhd0IsU0FBUyxDQUFDLFdBQVcsc1VBQXNVLGdIQUFnSCx5Q0FBeUMsa0ZBQWtGLG9GQUFvRiwrRkFBK0YsR0FBRyxvQkFBb0IsMkJBQTJCLEdBQUcsY0FBY3BCLFFBQVEsVUFBVSxDQUFDSixRQUFRLGFBQWF3QixTQUFTLENBQUMsV0FBVyxpRUFBaUUsb2NBQW9jLG9HQUFvRyxzREFBc0QsK0RBQStELDBGQUEwRiwwRkFBMEYsbURBQW1ELEdBQUcsb0JBQW9CLDJFQUEyRSwwR0FBMEcsNkNBQTZDLDREQUE0RCxHQUFHLGFBQWEsK0RBQStELHlFQUF5RXBCLFFBQVEsVUFBVSxDQUFDSixRQUFRLGFBQWF3QixTQUFTLENBQUMsV0FBVyxnQ0FBZ0Msc0NBQXNDLG9FQUFvRSw4Q0FBOEMsR0FBRyxvQkFBb0IsR0FBRyxhQUFhLDJDQUEyQ3BCLFFBQVEsVUFBVSxDQUFDRCxZQUFXLEVBQUtxQixTQUFTLENBQUMsV0FBVyxxREFBcUQsR0FBRyxvQkFBb0IsR0FBRyxhQUFhLHlEQUF5RHBCLFFBQVEsZ0IsVUNBdnFOdkMsRUFBT0MsUUFBVSxDQUFDLENBQUMyRCxLQUFLLGVBQWVDLE1BQU0sZ0JBQWdCLENBQUNELEtBQUssVUFBVUMsTUFBTSxXQUFXLENBQUNELEtBQUssU0FBU0MsTUFBTSxRQUFRQyxTQUFTLENBQUMsQ0FBQ0YsS0FBSyxXQUFXQyxNQUFNLDJCQUEyQjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLE1BQU1DLE1BQU0sWUFBWTdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLFNBQVNDLE1BQU0sZ0JBQWdCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssV0FBV0MsTUFBTSxXQUFXN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssWUFBWUMsTUFBTSxZQUFZN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssV0FBV0MsTUFBTSxXQUFXN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxTQUFTN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxNQUFNN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssV0FBV0MsTUFBTSxNQUFNN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssYUFBYUMsTUFBTSxNQUFNN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxLQUFLN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxLQUFLN0MsTUFBTSxTQUFTUixXQUFXLGdCQUFnQixDQUFDb0QsS0FBSyxPQUFPQyxNQUFNLE9BQU9DLFNBQVMsQ0FBQyxDQUFDRixLQUFLLGFBQWFDLE1BQU0sbUJBQW1CN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssWUFBWUMsTUFBTSxrQkFBa0I3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyxRQUFRQyxNQUFNLGNBQWM3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyxhQUFhQyxNQUFNLG1CQUFtQjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLHFCQUFxQkMsTUFBTSw0QkFBNEI3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyx1QkFBdUJDLE1BQU0sOEJBQThCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssb0JBQW9CQyxNQUFNLDJCQUEyQjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLHdCQUF3QkMsTUFBTSwrQkFBK0I3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyx1QkFBdUJDLE1BQU0sOEJBQThCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUsscUJBQXFCQyxNQUFNLDRCQUE0QjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLFNBQVNDLE1BQU0sbUJBQW1CN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssV0FBV0MsTUFBTSxxQkFBcUI3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyxjQUFjQyxNQUFNLHdCQUF3QjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLGNBQWNDLE1BQU0sd0JBQXdCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssWUFBWUMsTUFBTSxzQkFBc0I3QyxNQUFNLFNBQVNSLFdBQVcsY0FBYyxDQUFDb0QsS0FBSyxpQkFBaUJDLE1BQU0sMkJBQTJCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUsscUJBQXFCQyxNQUFNLCtCQUErQjdDLE1BQU0sU0FBU1IsV0FBVyxjQUFjLENBQUNvRCxLQUFLLFFBQVFDLE1BQU0sa0JBQWtCN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxlQUFlN0MsTUFBTSxTQUFTUixXQUFXLGNBQWMsQ0FBQ29ELEtBQUssU0FBU0MsTUFBTSxlQUFlN0MsTUFBTSxTQUFTUixXQUFXLGdCQUFnQixDQUFDb0QsS0FBSyxTQUFTQyxNQUFNLGVBQWUsQ0FBQ0QsS0FBSyxRQUFRQyxNQUFNLFcsVUNBcjFGN0QsRUFBT0MsUUFBVSxDQUFDLENBQUMyRCxLQUFLLGVBQWVDLE1BQU0sZ0JBQWdCLENBQUNELEtBQUssVUFBVUMsTUFBTSxXQUFXLFNBQVMsT0FBTyxDQUFDRCxLQUFLLFNBQVNDLE1BQU0sZUFBZSxDQUFDRCxLQUFLLFFBQVFDLE1BQU0sVyxVQ0F0SzdELEVBQU9DLFFBQVUsSSxVQ0FqQkQsRUFBT0MsUUFBVSxDQUFDLE9BQU8sNmxCLFVDQXpCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw2ZkFBNmYsT0FBTywwK0IsVUNBN2hCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw4a0IsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHlQLFVDQXpCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxxa0IsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHlXQUF5VyxPQUFPLHN6QixVQ0F6WUQsRUFBT0MsUUFBVSxDQUFDLE9BQU8scVVBQXFVLE9BQU8sc2FBQXNhLE9BQU8sa2EsVUNBbHhCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxxbkIsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLDJVQUEyVSxPQUFPLHd0QixVQ0EzV0QsRUFBT0MsUUFBVSxDQUFDLE9BQU8sMlQsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHViLFVDQXpCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxtVkFBbVYsT0FBTywreUIsVUNBblhELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHNPQUFzTyxPQUFPLDhQLFVDQXRRRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw0S0FBNEssT0FBTyxtcUIsVUNBNU1ELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLDIwQkFBMjBCLGNBQWMscTJDQUFxMkMsT0FBTywyL0JBQTIvQixjQUFjLDYwQ0FBNjBDLE9BQU8sb2pDLFVDQTNqSkQsRUFBT0MsUUFBVSxDQUFDLE9BQU8sdXZDLFVDQXpCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxvUkFBb1IsT0FBTyx1eUIsVUNBcFRELEVBQU9DLFFBQVUsQ0FBQyxTQUFTLDhoQyxVQ0EzQkQsRUFBT0MsUUFBVSxDQUFDLE9BQU8sNFBBQTRQLE9BQU8sdVksVUNBNVJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHlQQUF5UCxPQUFPLDBWLFVDQXpSRCxFQUFPQyxRQUFVLENBQUMsY0FBYyx1NUJBQXU1QixPQUFPLG80QixVQ0E5N0JELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHdZLFVDQXpCRCxFQUFPQyxRQUFVLENBQUMsT0FBTyx3bEIsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLDZQQUE2UCxPQUFPLHdlLFVDQTdSRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxreENBQWt4QyxPQUFPLDR3QkFBNHdCLE9BQU8sazlCLFVDQXJrRUQsRUFBT0MsUUFBVSxDQUFDLE9BQU8sbVpBQW1aLE9BQU8sZ25CLFNDQW5iRCxFQUFPQyxRQUFVLENBQUMsT0FBTywyTEFBMkwsT0FBTyx1WEFBdVgsT0FBTyw4UUFBOFEsT0FBTyx1ZixTQ0E5MkJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHFOQUFxTixPQUFPLG9OQUFvTixPQUFPLDBTQUEwUyxPQUFPLCtTLFNDQWp3QkQsRUFBT0MsUUFBVSxDQUFDLE9BQU8seVksVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLGtYQUFrWCxPQUFPLHFVLFVDQWxaRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw4UEFBOFAsT0FBTyxnZixVQ0E5UkQsRUFBT0MsUUFBVSxDQUFDLE9BQU8sNFcsVUNBekJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHFVQUFxVSxPQUFPLHdaLFVDQXJXRCxFQUFPQyxRQUFVLENBQUMsT0FBTyxnVUFBZ1UsT0FBTywrdkIsVUNBaFdELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLHFWQUFxVixPQUFPLCtTLFVDQXJYRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw0VixVQ0F6QkQsRUFBT0MsUUFBVSxDQUFDLGVBQWUsbUVBQW1FLG9CQUFvQixzakIsVUNBeEhELEVBQU9DLFFBQVUsQ0FBQyxrQkFBa0IseUhBQXlILDZCQUE2Qix1REFBdUQsZ0JBQWdCLDRDLFVDQWpRRCxFQUFPQyxRQUFVLENBQUMsT0FBTyw2VkFBNlYsV0FBVyx1WEFBdVgsT0FBTyw2TyxVQ0EvdkJELEVBQU9DLFFBQVUsQ0FBQyxPQUFPLGtkQUFrZCxPQUFPLDYwQixVQ0FsZkQsRUFBT0MsUUFBVSxDQUFDNEQsTUFBTSxTQUFTRixTQUFTLENBQUMsQ0FBQ0UsTUFBTSxvQkFBb0JFLGFBQWEsQ0FBQyxDQUFDQyxRQUFRLGtGQUFrRixDQUFDQSxRQUFRLCtNQUErTSxRLFVDQXZZaEUsRUFBT0MsUUFBVSxDQUFDNEQsTUFBTSxhLFVDQXhCN0QsRUFBT0MsUUFBVSxDQUFDNEQsTUFBTSxrQixVQ0F4QjdELEVBQU9DLFFBQVUsQ0FBQzRELE1BQU0sMkJBQTJCRixTQUFTLENBQUMsQ0FBQ0UsTUFBTSxzQ0FBc0NFLGFBQWEsQ0FBQyxDQUFDQyxRQUFRLCtFQUErRSxDQUFDSCxNQUFNLHNDQUFzQyxDQUFDQSxNQUFNLDBCQUEwQkUsYUFBYSxDQUFDLENBQUNDLFFBQVEsb0osVUNBclRoRSxFQUFPQyxRQUFVLENBQUM0RCxNQUFNLGMsVUNBeEI3RCxFQUFPQyxRQUFVLENBQUM0RCxNQUFNLFdBQVdGLFNBQVMsQ0FBQyxDQUFDRSxNQUFNLHNCQUFzQkUsYUFBYSxDQUFDLENBQUNDLFFBQVEsK0VBQStFLENBQUNBLFFBQVEsK0dBQStHLENBQUNILE1BQU0sa0JBQWtCLENBQUNBLE1BQU0sbUJBQW1CLENBQUNBLE1BQU0seURBQXlERSxhQUFhLENBQUMsQ0FBQ0MsUUFBUSx3TCxVQ0FsYmhFLEVBQU9DLFFBQVUsQ0FBQzRELE1BQU0sYyxVQ0F4QjdELEVBQU9DLFFBQVUsQ0FBQzRELE1BQU0sVUFBVUYsU0FBUyxDQUFDLENBQUNFLE1BQU0sa0JBQWtCLENBQUNBLE1BQU0sVUFBVTVDLFFBQVEsQ0FBQyxDQUFDSyxRQUFRLENBQUMsNkgsVUNBekd0QixFQUFPQyxRQUFVLENBQUM0RCxNQUFNLGVBQWVGLFNBQVMsQ0FBQyw0Q0FBNEMsU0FBUyxHQUFHLHNJQUFzSSxTQUFTLHlCLFVDQXhQM0QsRUFBT0MsUUFBVSxDQUFDSyxLQUFLIiwiZmlsZSI6Ijc5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge2NvbnN0cnVjdG9yczp7aGlzdG9yeXM6W3tvdmVybG9hZHM6W3tkZXNjcmlwdGlvbjonQ3JlYXRlIGFuIG9iamVjdCBvZiB0eXBlIElFbnVtZXJhYmxlIGZyb20gc291cmNlJ31dfV19LG5hbWU6J0VudW1lcmFibGUnLHByb3BlcnRpZXM6W3tuYW1lOidhY3Rpb25zJyxoaXN0b3J5czpbe2RlcHJlY2F0ZWQ6MCxkZXNjcmlwdGlvbjonQW4gb2JqZWN0IGNvbnRhaW5zIHNhbWUgdXNlZnVsIGFjdGlvbnMnfV19LHtuYW1lOidjb21wYXJlcnMnLGhpc3RvcnlzOlt7ZGVwcmVjYXRlZDowLGRlc2NyaXB0aW9uOidBbiBvYmplY3QgY29udGFpbnMgc2FtZSB1c2VmdWwgY29tcGFyZXJzJ31dfSx7bmFtZTonY29uZmlnJyxoaXN0b3J5czpbe2RlcHJlY2F0ZWQ6MCxkZXNjcmlwdGlvbjonR2xvYmFsIGNvbmZpZyd9XX0se25hbWU6J3ByZWRpY2F0ZXMnLGhpc3RvcnlzOlt7ZGVwcmVjYXRlZDowLGRlc2NyaXB0aW9uOidBbiBvYmplY3QgY29udGFpbnMgc2FtZSB1c2VmdWwgcHJlZGljYXRlcyd9XX0se25hbWU6J3NlbGVjdG9ycycsaGlzdG9yeXM6W3tkZXByZWNhdGVkOjAsZGVzY3JpcHRpb246J0FuIG9iamVjdCBjb250YWlucyBzYW1lIHVzZWZ1bCBzZWxlY3RvcnMnfV19XSxtZXRob2RzOlt7bmFtZTonYXNFbnVtZXJhYmxlJyxoaXN0b3J5czpbe2RlcHJlY2F0ZWQ6MCxvdmVybG9hZHM6W3tkZXNjcmlwdGlvbjonQ3JlYXRlIGFuIG9iamVjdCBvZiB0eXBlIElFbnVtZXJhYmxlIGZyb20gc291cmNlJ31dfV19LHtuYW1lOidlbXB0eScsaGlzdG9yeXM6W3tkZXByZWNhdGVkOjAsb3ZlcmxvYWRzOlt7ZGVzY3JpcHRpb246J0NyZWF0ZSBhbiBlbXB0eSBJRW51bWVyYWJsZSBvYmplY3QnfV19XX1dfSIsIm1vZHVsZS5leHBvcnRzID0ge2NvbnN0cnVjdG9yczp7aGlzdG9yeXM6W3tvdmVybG9hZHM6W3tkZXNjcmlwdGlvbjonQ3JlYXRlIGFuIG9iamVjdCBvZiB0eXBlIElFbnVtZXJhYmxlIGZyb20gc291cmNlJ31dfV19fSIsIm1vZHVsZS5leHBvcnRzID0ge2hpc3RvcnlzOlt7b3ZlcmxvYWRzOlt7ZGVzY3JpcHRpb246J0NyZWF0ZSBhbiBvYmplY3Qgb2YgdHlwZSBJRW51bWVyYWJsZSBmcm9tIHNvdXJjZSd9XX1dfSIsIm1vZHVsZS5leHBvcnRzID0ge2hpc3RvcnlzOlt7b3ZlcmxvYWRzOlt7ZGVzY3JpcHRpb246J0NyZWF0ZSBhbiBlbXB0eSBJRW51bWVyYWJsZSBvYmplY3QnfV19XX0iLCJtb2R1bGUuZXhwb3J0cyA9IHtoaXN0b3J5czpbe2Rlc2NyaXB0aW9uOidBbiBvYmplY3QgY29udGFpbnMgc2FtZSB1c2VmdWwgYWN0aW9ucyd9XX0iLCJtb2R1bGUuZXhwb3J0cyA9IHtoaXN0b3J5czpbe2Rlc2NyaXB0aW9uOidBbiBvYmplY3QgY29udGFpbnMgc2FtZSB1c2VmdWwgY29tcGFyZXJzJ31dfSIsIm1vZHVsZS5leHBvcnRzID0ge2hpc3RvcnlzOlt7ZGVzY3JpcHRpb246J0dsb2JhbCBjb25maWcnfV19IiwibW9kdWxlLmV4cG9ydHMgPSB7aGlzdG9yeXM6W3tkZXNjcmlwdGlvbjonQW4gb2JqZWN0IGNvbnRhaW5zIHNhbWUgdXNlZnVsIHByZWRpY2F0ZXMnfV19IiwibW9kdWxlLmV4cG9ydHMgPSB7aGlzdG9yeXM6W3tkZXNjcmlwdGlvbjonQW4gb2JqZWN0IGNvbnRhaW5zIHNhbWUgdXNlZnVsIHNlbGVjdG9ycyd9XX0iLCJtb2R1bGUuZXhwb3J0cyA9IHtjbGFzczonY2xhc3MnLGludGVyZmFjZTonaW50ZXJmYWNlJyxvYmplY3Q6J29iamVjdCcsY29uc3RydWN0b3I6J2NvbnN0cnVjdG9yJyxjb25zdHJ1Y3RvcnM6J2NvbnN0cnVjdG9ycycscHJvcGVydHk6J3Byb3BlcnR5Jyxwcm9wZXJ0aWVzOidwcm9wZXJ0aWVzJyxtZXRob2Q6J21ldGhvZCcsbWV0aG9kczonbWV0aG9kcycsc2luY2U6J3NpbmNlJyxkZXByZWNhdGVkOidkZXByZWNhdGVkJyxkZXRhaWxzOidkZXRhaWxzJyxkZXNjcmlwdGlvbjonZGVzY3JpcHRpb24nLHN1bW1hcnk6J3N1bW1hcnknLHdhcm5pbmc6J3dhcm5pbmcnLHdhcm5pbmdzOid3YXJuaW5ncycscmVtYXJrOidyZW1hcmsnLHJlbWFya3M6J3JlbWFya3MnLGV4YW1wbGU6J2V4YW1wbGUnLGV4YW1wbGVzOidleGFtcGxlcycsc3RhdGljOidzdGF0aWMnLG5ldzonbmV3JyxzZWU6J3NlZScsZGVjbGFyZTonZGVjbGFyZScscGFyYW1ldGVyczoncGFyYW1ldGVycycscGFyYW1ldGVyOidwYXJhbWV0ZXInLHJldHVybnM6J3JldHVybiB2YWx1ZScsZ2VuZXJpY3M6J3R5cGUgcGFyYW1ldGVycycsYXBpczonQVBJcycsZ3VpZGU6J0d1aWRlJyxwdWJsaXNoOidwdWJsaXNoJyx0aW1lOid0aW1lJyxkYXRlOidkYXRlJyxwcmVwdWJsaXNoOidwcmVwdWJsaXNoJyx2ZXJzaW9uOid2ZXJzaW9uJyxhdXRob3I6J2F1dGhvcicsZW1haWw6J2VtYWlsJyxwcm9qZWN0Oidwcm9qZWN0JyxkZWZhdWx0OidkZWZhdWx0Jyx2YWx1ZTondmFsdWUnLGRlZmF1bHRWYWx1ZTonZGVmYXVsdCB2YWx1ZScscmVhZG9ubHk6J3JlYWRvbmx5JyxsYXp5OidkZWZlcnJlZCBleGVjdXRpb24nLHRyeTondHJ5IGl0JyxydW46J3J1bicsY2xlYXI6J2NsZWFyJyxjbG9zZTonY2xvc2UnLGxvYWRSdW50aW1lOidsb2FkaW5nIHJ1bnRpbWUnLGV4ZWN1dGluZzonZXhlY3V0aW5nJyxlbmFibGVFeHRlbmQ6J2VuYWJsZSBleHRlbmRzIG9mIEFycmF5JyxuZXdJbnN0YW5jZTp7b25seTonY2FuIG9ubHkgdXNlIG5ldyBvcGVyYXRvcicsYm90aDonY2FuIHVzZSBuZXcgb3BlcmF0b3Igb3Igbm90JyxjYW5ub3Q6J2NhbiBub3QgdXNlIG5ldyBvcGVyYXRvcid9fSIsIm1vZHVsZS5leHBvcnRzID0gW3twdWJsaXNoOicyMDE3LTAzLTI3Jyxjb250ZW50czpbJ+S8mOWMluS6humDqOWIhuS7o+eggee7k+aehCcsJ+aWsOWiniDlr7kgYXJyYXlDb21wYXJlciDnmoTpu5jorqTmlK/mjIEnLCfmlrDlop7kuoYg5a+557ud5aSn6YOo5YiGIHNlbGVjdG9yLCBwcmVkaWNhdGUsIGNvbXBhcmVyIOWPguaVsOagoemqjCcsJ+aWsOWiniDnu53lpKfpg6jliIbnmoQgc2VsZWN0b3IsIHByZWRpY2F0ZSwgY29tcGFyZXIg5Y+C5pWw5Z2H5pSv5oyBIFN0cmluZyDmiJYgU3ltYm9sIOexu+Wei+aVsOaNriDooajnpLrpgInmi6nlr7nosaHlr7nlupTnmoTlrZfmrrUg55qE5Yqf6IO9Jywn5paw5aKeIEVudW1lcmFibGUucHJlZGljYXRlcy5leGlzdHMg5bGe5oCnLCDooajnpLrpnZ7nqbrnrZvpgInlmagnLCfmlrDlop4gRW51bWVyYWJsZS5wcmVkaWNhdGVzLnJlZ2V4cCDmlrnms5UsIOeUn+aIkOato+WImeWMuemFjeeahOetm+mAieWZqCcsJ+aWsOWiniBFbnVtZXJhYmxlLnByZWRpY2F0ZXMubm90IOaWueazlSwg55Sf5oiQ6YC76L6R6Z2e562b6YCJ5ZmoJywn5paw5aKeIEVudW1lcmFibGUucHJlZGljYXRlcy5zZWxlY3RvciDmlrnms5UsIOeUn+aIkOmAieaLqeetm+mAieWZqCcsJ+aWsOWiniBFbnVtZXJhYmxlLnByZWRpY2F0ZXMuZXF1YWxpdHksIEVudW1lcmFibGUucHJlZGljYXRlcy5zdHJpY3QsIEVudW1lcmFibGUucHJlZGljYXRlcy5zYW1lIOaWueazlSwg55Sf5oiQ5q+U6L6D562b6YCJ5ZmoJ10sdmVyc2lvbjonMi4xLjE1J30se3B1Ymxpc2g6JzIwMTctMDQtMDUnLGNvbnRlbnRzOlsn5LyY5YyWIHNlbGVjdE1hbnkg5pa55rOVLCDkvb/nmoTkvb/nlKjkuIrmm7TmjqXov5FsaW5x5Y6f55Sf55qE5pa55rOVLiDkv67lpI0gc2VsZWN0TWFueSDmlrnms5UgY29sbGVjdGlvblNlbGVjdG9yIOi/lOWbniBJdGVyYXRvcixzdHJpbmcsb2JqZWN0IOWvueixoeaYr+WHuueOsOW8guW4uOeahGJ1ZycsJ+S/ruaUuSBkZWZhdWx0R3JvdXBSZXN1bHRTZWxlY3RvciDkuLogZGVmYXVsdFJlc3VsdFNlbGVjdG9yLCDkv67mlLkgRW51bWVyYWJsZS5zZWxlY3RvcnMuZ3JvdXBSZXN1bHQg5Li6IEVudW1lcmFibGUuc2VsZWN0b3JzLnJlc3VsdCcsJ+S/ruaUuSBzZWxlY3RNYW55IOaWueazleeahCByZXN1bHRTZWxlY3RvciDlj4LmlbDnmoTnu5PmnoTlkozpu5jorqTlgLwsIOS4jiBkZWZhdWx0UmVzdWx0U2VsZWN0b3Ig5LiA6Ie0Jywn5aKe5YqgIHppcCDmlrnms5XnmoQgcmVzdWx0U2VsZWN0b3Ig55qE6buY6K6k5YC85Li6IGRlZmF1bHRSZXN1bHRTZWxlY3RvciddLHZlcnNpb246JzIuMS4xNid9LHtwdWJsaXNoOicyMDE3LTA0LTEyJyxjb250ZW50czpbJ+aWsOWiniBmaW5kTGFzdCDmlrnms5UnLCfmlrDlop4gRW51bWVyYWJsZS5jb21wYXJlcnMuZ3JlYXRlciDmlrnms5UnLCfmlrDlop4gRW51bWVyYWJsZS5jb21wYXJlcnMubGVzcyDmlrnms5UnLCfmlrDlop4gRW51bWVyYWJsZS5wcmVkaWNhdGVzLnByb3BlcnRpZXMg5pa55rOVLCDnlJ/miJDkuIDkuKrlsZ7mgKfnrZvpgInlmagnLCfmlrDlop7miYDmnInnmoQgcHJlZGljYXRlIOWPguaVsCwg5aaC5p6c5L2/55SoIEFycmF5IOaIluiAhSBPYmplY3Qg57G75Z6L5L2c5Li65Y+C5pWw5pe2LCDoh6rliqjnu4/ov4cgRW51bWVyYWJsZS5wcmVkaWNhdGVzLnByb3BlcnRpZXMg5pa55rOV6L2s6K+R5oiQ5LiA5Liq562b6YCJ5ZmoJywn5LyY5YyWIGNvbXBhcmVyIC8gcHJlZGljYXRlIC8gc2VsZWN0b3Ig57G75Z6L55qE5Y+C5pWwIOi9rOWMlui/h+eoi+eahOaViOeOhyddLHZlcnNpb246JzIuMS4xNyd9LHtwdWJsaXNoOicyMDE3LTA4LTMwJyxjb250ZW50czpbJ+aWsOWiniBFbnVtZXJhYmxlLnR5cGVBcyDmlrnms5XnlKjmnaXlr7nmjIflrprnsbvlnovorr7nva4gYXNFbnVtZXJhYmxlIOi9rOaNouaXtueahOWPguiAg+exu+WeiycsJ+aWsOWiniBFbnVtZXJhYmxlLnR5cGVzIOWvueixoSzljIXlkKvlkITlj4LogIPnsbvlnovnmoTluLjph4/lgLwnLCdFbnVtZXJhYmxlLmFkZFBsdWdpbnPjgIFFbnVtZXJhYmxlLnJlbW92ZVBsdWdpbnMg5pa55rOV5aKe5Yqg6L+U5Zue5YC8LOaWueS+v+mTvuW8j+iwg+eUqCcsJ+aWsOWiniBFbnVtZXJhYmxlLmNvbXBhcmVycy5pZ25vcmVDYXNlIOW/veeVpeWkp+Wwj+WGmeeahOebuOetieavlOi+g+WZqCcsJ+aWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUubGVmdEpvaW7jgIFJRW51bWVyYWJsZS5wcm90b3R5cGUucmlnaHRKb2luIOaWueazleeUqOadpeWvueS4pOS4quW6j+WIl+WIhuWIq+i/m+ihjOWGhemDqOW3puiBlOaOpeS4juWGhemDqOWPs+iBlOaOpScsJ+S/ruWkjSBjb25jYXQg5pa55rOV5Zyo5Y+C5pWw5YC85Li6IFN0cmluZyDmiJYgQXJndW1lbnRzIOexu+Wei+aYr+e7k+aenOi2heWHuumihOacn+eahGJ1ZycsJ+enu+mZpOi/h+aXtueahOWKn+iDvSBhcnJheUNvbXBhcmVy44CBcHJlZGljYXRlQ29tcGFyZXInLCfmlrDlop4gRW51bWVyYWJsZS5leHRlbmRzLmxhenkg6YWN572u6YCJ6aG5Jywn5L+u5aSNIOWQr+eUqOaJqeWxleWQjiDlr7nosaHkuIrkuI3og73kvb/nlKggZ2V0RW51bWVyYXRvciDmlrnms5XnmoTpl67popgnLCfmlrDlop4gSUVudW1lcmFibGUucHJvdG90eXBlLmNodW5rIOaWueazleeUqOadpeWvueW6j+WIl+i/m+ihjOWIhuWdlycsJ+aWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUucHJvZHVjdCDmlrnms5XnlKjmnaXorqHnrpfkuZjnp68nLCfmlrDlop4gSUVudW1lcmFibGUucHJvdG90eXBlLmxlZnRQYWTjgIFJRW51bWVyYWJsZS5wcm90b3R5cGUucmlnaHRQYWQg5pa55rOVJywn5paw5aKeIElFbnVtZXJhYmxlLnByb3RvdHlwZS5yYW5kIOaWueazlScsJycsJ0J1Z3MnLCfosIPnlKggT2JqZWN0IOWvueixoeeahCBhc0VudW1lcmFibGUg5pa55rOV5bCG5Lya6L+U5Zue5LiA5Liq5LiN5Y+v5o6n55qE57uT5p6cJ10sdmVyc2lvbjonMi4xLjE4J30se3B1Ymxpc2g6JzIwMTctMDktMDgnLGNvbnRlbnRzOlsn5paw5aKeKE5ldyk6JywnMS4g5aKe5Yqg5ZCEIOmAieaLqeWZqChTZWxlY3Rvcikv5q+U6L6D5ZmoKENvbXBhcmVyKS/nrZvpgInlmagoUHJlZGljYXRlKSDlr7kgTnVtYmVyL1N5bWJvbCDnsbvlnovlj4LmlbDnmoTmlK/mjIEnLCcyLiDmlrDlop4gRW51bWVyYWJsZS5zZWxlY3RvcnMuam9pbiDkvZzkuLogZGVmYXVsdEpvaW5TZWxlY3RvcicsJzMuIOaWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUuaW5uZXJKb2luIOaWueazleS4juWOn+WFiOeahCBqb2luIOaWueazleWKn+iDveS4gOiHtCwg5Li76KaB5Li65LqG5Yy65Yir5LuF5pyJ5LiA5Liq5Y+C5pWw55qE5oOF5Ya15LiL55qE6YC76L6RJywnNC4g5paw5aKeIEVudW1lcmFibGUubm9Db25mbGljdCDmlrnms5Ug55So5LqO6Kej5Yaz6YeN5aSN5byV55So55qE6Zeu6aKYJywnJywn5LyY5YyWKE9wdGltaXphdGlvbik6JywnMS4g5LyY5YyW5LqGIGpvaW4g5pa55rOV55qE5aSE55CG6YC76L6RJywnMi4g5bCGIElHcm91cGluZy5wcm90b3R5cGUua2V5IOS4jiBJQ2h1bmsucHJvdG90eXBlLmluZGV4IOiuvue9ruaIkOWPquivuycsJzMuIOS4uiBncm91cEpvaW4sIGxlZnRKb2luLCByaWdodEpvaW4g562J5pa55rOV55qEIHJlc3VsdFNlbGVjdG9yIOWPguaVsOiuvue9ruS6hiBkZWZhdWx0Sm9pblNlbGVjdG9yIOm7mOiupOWAvCcsJzQuIOS8mOWMluS6hiBFbnVtZXJhYmxlLmV4dGVuZC9FbnVtZXJhYmxlLnVuZXh0ZW5kL0VudW1lcmFibGUuYWRkUGx1Z2lucy9FbnVtZXJibGUucmVtb3ZlUGx1Z2lucyDnrYnmlrnms5UsIOW5tuaWsOWinuS6hiBFbnVtZXJhYmxlLmV4dGVuZEFsbC9FbnVtZXJhYmxlLnVuZXh0ZW5kQWxsIOaWueazlScsJycsJ+S/ruWkjShGaXhlZCk6JywnMS4g5L+u5aSN5LiA5aSE6ZKI5a+5IFN0cmluZyDmianlsZXlkI4gU3RyaW5nLnByb3RvdHlwZS5zbGljZSDov5Tlm57otoXlh7rpooTmnJ/nmoTpl67popgnLCcyLiDkv67lpI3nlLEgZ3JvdXBCeS9ncm91cEpvaW4vY2h1bmsg562J5pa55rOV6I635Y+W5Yiw55qEIElHcm91cGluZy9JQ2h1bmsg5a+56LGh5LiN6IO96KKr6YeN5aSN6YGN5Y6G55qE6Zeu6aKYJywnMy4g5L+u5aSN5a+5IE9iamVjdCDlr7nosaHkvb/nlKggYXNFbnVtZXJhYmxlIOaWueazleaXtuS4jeiDvei/lOWbnuatpOWvueixoemUruWAvOWvueW6j+WIl+aIluWHuueOsOmUmeivr+eahGJ1ZyddLHZlcnNpb246JzIuMS4xOSd9LHtwdWJsaXNoOicyMDE3LTA5LTIyJyxjb250ZW50czpbJ+aWsOWinihOZXcpOicsJzEuIOaWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUucmFuZG9tIC8gSUVudW1lcmFibGUucHJvdG90eXBlLnJhbmRvbU9yRGVmYXVsdCDmlrnms5UsIOeUqOadpeS7juW6j+WIl+S4remaj+acuuiOt+WPluS4gOS4quWFg+e0oCcsJzIuIOaWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUud2lwZSDmlrnms5UsIOeUqOadpeWJlOmZpOW6j+WIl+S4rea7oei2s+adoeS7tuaMh+WumuaVsOmHj+eahOWFg+e0oCcsJzMuIOaWsOWiniBJRW51bWVyYWJsZS5wcm90b3R5cGUubmVhckJ5IOaWueazlSwg55So5p2l5a+55bqP5YiX5Lit55u45ZCM5LiU55u46YK755qE5YWD57Sg6L+b6KGM5YiG57uEJywnNC4g5paw5aKeIEVudW1lcmFibGUuYmV0d2VlbiDmlrnms5UsIOeUn+aIkOiMg+WbtOWGheeahOaVtOaVsOW6j+WIlycsJzUuIOaWsOWiniBFbnVtZXJhYmxlLmZyb20g5pa55rOVLCDlip/og73kuI4gYXNFbnVtZXJhYmxlIOaWueazleS4gOiHtCcsJzYuIOS4uiBFbnVtZXJhYmxlLnJhbmdlIOaWueazleaWsOWinuesrOS4ieS4quWPguaVsCwg6K6+572u5q2l6ZW/JywnNy4g5paw5aKeIEVudW1lcmFibGUuZ2VuZXJhdGUg5pa55rOVLCDpgJrov4fnlJ/miJDmlrnms5XmnoTlu7rmlrDluo/liJcnLCc4LiDmlrDlop4gSUVudW1lcmFibGUucHJvdG90eXBlLnNlcGFyYXRlIC8gSUVudW1lcmFibGUucHJvdG90eXBlLmNvbWJpbmUg5pa55rOVLCDliIbliKvnlKjmnaXlr7npgJLlvZLnmoTnu5PmnoTov5vooYzmi4bop6PkuI7lkIjlubYnLCcnLCfkvJjljJYoT3B0aW1pemF0aW9uKTonLCcxLiDkvJjljJYgY2h1bmsvbGVmdFBhZC9yaWdodFBhZC9yYW5kIOaWueazleeahOmAu+i+kScsJzIuIOS8mOWMliBkZWZhdWx0VmFsdWVTZWxlY3RvcicsJycsJ+S/ruWkjShGaXhlZCk6JywnMS4g5L+u5aSNIOW8gOWQr+aJqeWxleWQjiBhdmVyYWdlL2RlZmF1bHRJZkVtcHR5L2pvaW4g5pa55rOV6L+U5Zue6LaF5Ye66aKE5pyf5oiW5oql6ZSZ55qEYnVnJ10sdmVyc2lvbjonMi4xLjIwJ30se3B1Ymxpc2g6JzIwMTctMTEtMjAnLGNvbnRlbnRzOlsn5paw5aKeKE5ldyk6JywnMS4g5paw5aKeIElFbnVtZXJhYmxlLnByb3RvdHlwZS5pc1N1YiAvIElFbnVtZXJhYmxlLnByb3RvdHlwZS5pc1N1cGVyIOaWueazlSwg55So5p2l5Yik5pat5Lik5Liq5bqP5YiX55qE5LuO5bGe5YWz57O7JywnMi4g5paw5aKeIElFbnVtZXJhYmxlLnByb3RvdHlwZS5zeW1tZXRyaWMg5pa55rOVLCDnlKjmnaXorqHnrpfkuKTkuKrluo/liJfnmoTlr7nnp7Dlt67pm4YnLCcnLCfkvJjljJYoT3B0aW1pemF0aW9uKTonLCcxLiDkvJjljJYgb3JkZXJCeS9vcmRlckJ5RGVzY2VuZGluZy90aGVuQnkvdGhlbkJ5RGVzY2VuZGluZyDmlrnms5XnmoTmgKfog70nLCcnLCfkv67lpI0oRml4ZWQpOiddLHZlcnNpb246JzIuMS4yMSd9LHtwdWJsaXNoOicyMDE4LTAzLTIxJyxjb250ZW50czpbJ+aWsOWinihOZXcpOicsJzEuIOaWsOWiniBJVHJlZSDmjqXlj6MsIOaLpeacieWvueagkeW9oue7k+aehOeahOWfuuacrOaTjeS9nC4g5YyF5ZCrOiB2YWx1ZSwgY2hpbGRyZW4sIHZhbHVlcyDnrYnlsZ7mgKcsIOWMheWQqzogZGVwdGgsIGRlZ3JlZSwgZ2V0Q2hpbGQsIGdldFZhbHVlLCBicmVhZHRoVHJhdmVyc2UsIGJyZWFkdGhTZWFyY2gsIGJyZWFkdGhTdWJUcmVlLCBkZXB0aFRyYXZlcnNlLCBkZXB0aFNlYXJjaCwgZGVwdGhTdWJUcmVlLCBsb3dlc3RBbmNlc3RvciwgaXNEZXNjZW5kYW50T2YsIGlzQW5jZXN0b3JPZiwgcGF0aCwgcGF0aFRvLCBpc0JpbmFyeSwgaXNGdWxsQmluYXJ5LCBpc0NvbXBsZXRlQmluYXJ5LCBpc1Byb2ZlY3RCaW5hcnksIGFzQmluYXJ5IOetieaWueazlScsJzIuIOaWsOWiniBCaW5hcnlUcmVlIOexuywg5oul5pyJ5a+55LqM5Y+J5qCR55qE5Z+65pys5pON5L2cLiDljIXlkKs6IGxlZnQsIHJpZ2h0IOetieWxnuaApywg5YyF5ZCrOiBoYXNMZWZ0LCBoYXNSaWdodCwgcHJlT3JkZXIsIGluT3JkZXIsIHBvc3RPcmRlciDnrYnmlrnms5UnLCczLiDkv67mlLkgSUNvbWJpbmUg57un5om/IElUcmVlIOaOpeWPoywg5Y+v6L+b6KGM5qCR5b2i57uT5p6E55qE5pON5L2cJywnNC4g5paw5aKeIElFbnVtZXJhYmxlLnByb3RvdHlwZS5tYXhPckRlZmF1bHQsIElFbnVtZXJhYmxlLnByb3RvdHlwZS5taW5PckRlZmF1bHQg5pa55rOVJywnNS4g5Li6IG9iamVjdCDlr7nosaHmlrDlop4gYXNFbnVtZXJhYmxlKGNoaWxkcmVuU2VsZWN0b3IsIHZhbHVlU2VsZWN0b3IpIOmHjei9vSwg55So5LqO5oiW5LiA5LiqIElUcmVlIOWvueixoScsJzYuIOaWsOWiniB0b1ByZU9yZGVyLCB0b0luT3JkZXIsIHRvUG9zdE9yZGVyIOaWueazlSwg55So5LqO55Sf5oiQ5LiA5Liq5a6M5YWo5LqM5Y+J5qCRLCDliIbliKvkvb/lvpfmraTkuozlj4nmoJHnmoQg5YmN5bqP6YGN5Y6GfOS4reW6j+mBjeWOhnzlkI7luo/pgY3ljoYg55qE57uT5p6c5LiO5rqQ5bqP5YiX5LiA6Ie0JywnJywn5LyY5YyWKE9wdGltaXphdGlvbik6JywnMS4g5LyY5YyWIEl0ZXJhdG9yRW51bWVyYWJsZScsJycsJ+S/ruWkjShGaXhlZCk6J10sdmVyc2lvbjonMi4xLjIyJ30se3B1Ymxpc2g6JzIwMTgtMDMtMjknLGNvbnRlbnRzOlsn5paw5aKeKE5ldyk6JywnMS4g5aKe5YqgIElUcmVlLnByb3RvdHlwZS50b1ZhbHVlIOaWueazlSzlsIbmoJHlvaLnu5PmnoTovazljJYgb2JqZWN0IOWvueixoSAoIEpTT04g5pWw5o2uICknLCcyLiDlop7liqAgSVRyZWUucHJvdG90eXBlLmlzUGFyZW50T2YsIElUcmVlLnByb3RvdHlwZS5pc0NoaWxkT2YsIElUcmVlLnByb3RvdHlwZS5nZXRQYXJlbnQsIElUcmVlLnByb3RvdHlwZS5wcmV2LCBJVHJlZS5wcm90b3R5cGUucHJldkFsbCwgSVRyZWUucHJvdG90eXBlLm5leHQsIElUcmVlLnByb3RvdHlwZS5uZXh0QWxsLCBJVHJlZS5wcm90b3R5cGUuc2libGluZ3MsIElUcmVlLnByb3RvdHlwZS5nZXRQYXJlbnROb2RlLCBJVHJlZS5wcm90b3R5cGUucHJldk5vZGUsIElUcmVlLnByb3RvdHlwZS5wcmV2QWxsTm9kZXMsIElUcmVlLnByb3RvdHlwZS5uZXh0Tm9kZSwgSVRyZWUucHJvdG90eXBlLm5leHRBbGxOb2RlcywgSVRyZWUucHJvdG90eXBlLnNpYmxpbmdOb2RlcywgSVRyZWUucHJvdG90eXBlLnBhdGhOb2RlcywgSVRyZWUucHJvdG90eXBlLnBhdGhOb2Rlc1RvIOaWueazlSzmk43kvZzmoJHlvaLnmoTlkIToioLngrnlhbPns7snLCczLiDlop7liqAgSUVudW1lcmFibGUucHJvdG90eXBlLmVhY2gg5pa55rOVLOWvueW6j+WIl+S4reeahOavj+S4quWFg+e0oOaJp+ihjOS4gOasoeaTjeS9nCzlubbov5Tlm57luo/liJfmnKzouqsgKCDkuI4gZm9yRWFjaCDmlrnms5XnmoTljLrliKvlnKjkuo4gZWFjaCDmlrnms5Xlj6/ku6Xnu6fnu63pk77lvI/osIPnlKggKScsJzQuIOWinuWKoCBJRW51bWVyYWJsZS5wcm90b3R5cGUuc3BsaXQg5pa55rOVLOWvueW6j+WIl+aMieeFp+aMh+WumueahOadoeS7tui/m+ihjOaLhuWIhicsJzUuIOWinuWKoCBJRW51bWVyYWJsZS5wcm90b3R5cGUuaW5kaWNlcyDmlrnms5Us55So5L2/55So5LiA5Liq57Si5byV5bqP5YiX5LuO5rqQ5bqP5YiX5Lit55Sf5oiQ5LiA5Liq5paw5bqP5YiXJywnNi4g5aKe5YqgIElFbnVtZXJhYmxlLnByb3RvdHlwZS5wZXJtdXRhdGlvbiwgSUVudW1lcmFibGUucHJvdG90eXBlLmNvbWJpbmF0aW9uIOaWueazlSznlKjmnaXorqHnrpfmjpLliJfkuI7nu4TlkIgnLCc3LiDlop7liqAgRW51bWVyYWJsZS5zZXR0ZXJzLmNoaWxkcmVuLCBFbnVtZXJhYmxlLnNldHRlcnMudmFsdWUg5bGe5oCnLOS4gOS4qum7mOiupOeahCBjaGlsZHJlbi92YWx1ZSDorr7nva7lmagnLCc4LiDlop7liqAgRW51bWVyYWJsZS5zZXR0ZXJzLnByb3BlcnR5IOaWueazlSznlKjmnaXnlJ/miJDkuIDkuKrlsZ7mgKforr7nva7lmagnLCcnLCfkvJjljJYoT3B0aW1pemF0aW9uKTonLCcxLiDkvJjljJYgSVRyZWUucHJvdG90eXBlLmlzQW5jZXN0b3JPZiwgSVRyZWUucHJvdG90eXBlLmlzRGVzY2VuZGFudE9mIOaWueazleeahOaAp+iDvScsJzIuIOS8mOWMliBJRW51bWVyYWJsZS5wcm90b3R5cGUuY2h1bmssIElFbnVtZXJhYmxlLnByb3RvdHlwZS5ncm91cEJ5LCBJRW51bWVyYWJsZS5wcm90b3R5cGUuZ3JvdXBKb2luIOetieaWueazleaAp+iDvScsJzMuIOS8mOWMliBJVHJlZS5wcm90b3R5cGUubG93ZXN0QW5jZXN0b3Ig5pa55rOV55qE5oCn6IO9JywnNC4g5LyY5YyWIEVudW1lcmFibGUuc2VsZWN0b3JzLnByb3BlcnR5IOaWueazlSwg5aKe5Yqg5LiA5Liq5Y+C5pWw5o6n5Yi25piv5ZCm5b+955Wl5peg5pWI55qE5bGe5oCnJywnJywn5L+u5aSNKEZpeGVkKTonLCcxLiDkv67lpI0gSVRyZWUucHJvdG90eXBlLmxvd2VzdEFuY2VzdG9yIOWcqOWkhOeQhuiKgueCueWAvOS4umZhbHNl55qE5oOF5Ya15LiL6L+U5Zue6ZSZ6K+v55qE6Zeu6aKYJywnMi4g5L+u5aSNIElUcmVlLnByb3RvdHlwZS5sb3dlc3RBbmNlc3RvciDlnKjlpITnkIboioLngrnlgLznsbvlnovkuI7lj4LmlbDlgLznsbvlnovkuI3lkIzkvYbmlbDlgLznm7jnrYnnmoTmg4XlhrXkuIvov5Tlm57plJnor6/nmoTpl67popgnXSx2ZXJzaW9uOicyLjEuMjMnfSx7cHVibGlzaDonMjAyMC0wMy0wMycsY29udGVudHM6WyfmlrDlop4oTmV3KTonLCcxLiDkuLrkuIDkupvmlrnms5Xlop7liqDliKvlkI0sIOaWueS+v+WFtuS7luivreiogOS9v+eUqOiAheabtOWuueaYk+eahOi9rOenuycsJzIuIOaWsOWiniBjb25mbGljdCDmlrnms5XnlKjmnaXliKTmlq3kuIDkuKrluo/liJfkuK3mmK/lkKbljIXlkKvph43lpI3nmoTlhYPntKAnLCczLiDmlrDlop4gbmVhclNwbGl0IOaWueazleeUqOadpeWIhuWJsuS4gOS4quW6j+WIlyzkuI4gc3BsaXQg5pa55rOV5Yy65Yir5Zyo5LqO6L+e57ut55qE56ym5ZCI5p2h5Lu255qE5YiG5Ymy5YWD57Sg5LmL6Ze05bCG5LiN5Lya6KKr5YiG5Ymy5Ye656m65bqP5YiXJywnNC4g5paw5aKeIHNraXBTYW1lLCB0YWtlU2FtZSDmlrnms5XnlKjmnaXojrflj5bmiJblv73nlaXlvIDlpLTpg6jliIbnm7jlkIznmoTlhYPntKAnLCcnLCfkvJjljJYoT3B0aW1pemF0aW9uKTonLCcnLCfkv67lpI0oRml4ZWQpOicsJzEuIOS/ruWkjSBza2lwV2hpbGUsIHRha2VXaGlsZSDmlrnms5Xpu5jorqTlj4LmlbDplJnor6/nmoRidWcnXSx2ZXJzaW9uOicyLjEuMjQnfSx7cHJlcHVibGlzaDp0cnVlLGNvbnRlbnRzOlsn5paw5aKeKE5ldyk6JywnMS4g5aKe5YqgIHByb3BvcnRpb27jgIFza2lwUHJvcG9ydGlvbiwgdGFrZVByb3BvcnRpb24g5pa55rOVJywnJywn5LyY5YyWKE9wdGltaXphdGlvbik6JywnJywn5L+u5aSNKEZpeGVkKTonLCcxLiDkv67lpI3kuoYgSUVudW1lcmFibGUg5Lit5pyq5rOo5YaMIHJhbmRvbeOAgSByYW5kb21PckRlZmF1bHQg5pa55rOV55qE6Zeu6aKYJ10sdmVyc2lvbjonMi4xLjI1LnByZSd9XSIsIm1vZHVsZS5leHBvcnRzID0gW3tjb2RlOidpbnRyb2R1Y3Rpb24nLHRpdGxlOidJbnRyb2R1Y3Rpb24nfSx7Y29kZTonaW5zdGFsbCcsdGl0bGU6J0luc3RhbGwnfSx7Y29kZTonZ3VpZGVzJyx0aXRsZTonR3VpZGUnLGNoaWxkcmVuOlt7Y29kZTonaW5zdGFuY2UnLHRpdGxlOidHZXQgSUVudW1lcmFibGUgaW5zdGFuY2UnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTondXNlJyx0aXRsZTonU3RhcnQgdXNlJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J2NvbmZpZycsdGl0bGU6J0NvbmZpZ3VyYXRpb24nLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonc2VsZWN0b3InLHRpdGxlOidTZWxlY3Rvcicsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidwcmVkaWNhdGUnLHRpdGxlOidQcmVkaWNhdGUnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonY29tcGFyZXInLHRpdGxlOidDb21wYXJlcicsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidhY3Rpb24nLHRpdGxlOidBY3Rpb24nLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonc2V0dGVyJyx0aXRsZTon6K6+572u5ZmoJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J2l0ZXJhdG9yJyx0aXRsZTon6L+t5Luj5ZmoJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J2VudW1lcmF0b3InLHRpdGxlOifmnprkuL7lmagnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonZXh0ZW5kJyx0aXRsZTon5omp5bGVJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J3BsdWdpbicsdGl0bGU6J+aPkuS7ticsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9XX0se2NvZGU6J2FwaXMnLHRpdGxlOidBUElzJyxjaGlsZHJlbjpbe2NvZGU6J0JpbmFyeVRyZWUnLHRpdGxlOidCaW5hcnlUcmVlIENsYXNzJyxzaW5jZTonMi4xLjIyJyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0RpcmVjdG9yeScsdGl0bGU6J0RpcmVjdG9yeSBDbGFzcycsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidFbnRyeScsdGl0bGU6J0VudHJ5IENsYXNzJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0VudW1lcmFibGUnLHRpdGxlOidFbnVtZXJhYmxlIENsYXNzJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0VudW1lcmFibGUuYWN0aW9ucycsdGl0bGU6J0VudW1lcmFibGUuYWN0aW9ucyBPYmplY3QnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonRW51bWVyYWJsZS5jb21wYXJlcnMnLHRpdGxlOidFbnVtZXJhYmxlLmNvbXBhcmVycyBPYmplY3QnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonRW51bWVyYWJsZS5jb25maWcnLHRpdGxlOidFbnVtZXJhYmxlLmNvbmZpZyBPYmplY3QnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonRW51bWVyYWJsZS5wcmVkaWNhdGVzJyx0aXRsZTonRW51bWVyYWJsZS5wcmVkaWNhdGVzIE9iamVjdCcsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidFbnVtZXJhYmxlLnNlbGVjdG9ycycsdGl0bGU6J0VudW1lcmFibGUuc2VsZWN0b3JzIE9iamVjdCcsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidFbnVtZXJhYmxlLnNldHRlcnMnLHRpdGxlOidFbnVtZXJhYmxlLnNldHRlcnMgT2JqZWN0JyxzaW5jZTonMi4xLjIwJyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0lDaHVuaycsdGl0bGU6J0lDaHVuayBJbnRlcmZhY2UnLHNpbmNlOicyLjEuMTgnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonSUNvbWJpbmUnLHRpdGxlOidJQ29tYmluZSBJbnRlcmZhY2UnLHNpbmNlOicyLjEuMjInLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonSUVudW1lcmFibGUnLHRpdGxlOidJRW51bWVyYWJsZSBJbnRlcmZhY2UnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonSUVudW1lcmF0b3InLHRpdGxlOidJRW51bWVyYXRvciBJbnRlcmZhY2UnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfSx7Y29kZTonSUdyb3VwaW5nJyx0aXRsZTonSUdyb3VwaW5nIEludGVyZmFjZScsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidJTWFwRW51bWVyYWJsZScsdGl0bGU6J0lNYXBFbnVtZXJhYmxlIEludGVyZmFjZScsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidJT3JkZXJlZEVudW1lcmFibGUnLHRpdGxlOidJT3JkZXJlZEVudW1lcmFibGUgSW50ZXJmYWNlJyxzaW5jZTonMi4xLjE1JyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0lUcmVlJyx0aXRsZTonSVRyZWUgSW50ZXJmYWNlJyxzaW5jZTonMi4xLjIyJyxkZXByZWNhdGVkOicyLjEuMjUucHJlJ30se2NvZGU6J0xvb2t1cCcsdGl0bGU6J0xvb2t1cCBDbGFzcycsc2luY2U6JzIuMS4xNScsZGVwcmVjYXRlZDonMi4xLjI1LnByZSd9LHtjb2RlOidQbHVnaW4nLHRpdGxlOidQbHVnaW4gQ2xhc3MnLHNpbmNlOicyLjEuMTUnLGRlcHJlY2F0ZWQ6JzIuMS4yNS5wcmUnfV19LHtjb2RlOidjaGFuZ2UnLHRpdGxlOidDaGFuZ2UgTGlzdCd9LHtjb2RlOidhYm91dCcsdGl0bGU6J0Fib3V0J31dIiwibW9kdWxlLmV4cG9ydHMgPSBbe2NvZGU6J2ludHJvZHVjdGlvbicsdGl0bGU6J0ludHJvZHVjdGlvbid9LHtjb2RlOidpbnN0YWxsJyx0aXRsZTonSW5zdGFsbCd9LCdndWlkZXMnLCdhcGlzJyx7Y29kZTonY2hhbmdlJyx0aXRsZTonQ2hhbmdlIExpc3QnfSx7Y29kZTonYWJvdXQnLHRpdGxlOidBYm91dCd9XSIsIm1vZHVsZS5leHBvcnRzID0ge30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBmcnVpdHMgPSBbIFwiYXBwbGVcIiwgXCJtYW5nb1wiLCBcIm9yYW5nZVwiLCBcInBhc3Npb25mcnVpdFwiLCBcImdyYXBlXCIgXTtcXHJcXG5cXHJcXG4vLyBEZXRlcm1pbmUgd2hldGhlciBhbnkgc3RyaW5nIGluIHRoZSBhcnJheSBpcyBsb25nZXIgdGhhbiBcImJhbmFuYVwiLlxcclxcbmxldCBsb25nZXN0TmFtZSA9XFxyXFxuICAgIGZydWl0cy5hc0VudW1lcmFibGUoKS5hZ2dyZWdhdGUoXCJiYW5hbmFcIixcXHJcXG4gICAgICAgIChsb25nZXN0LCBuZXh0KSA9PlxcclxcbiAgICAgICAgICAgIG5leHQubGVuZ3RoID4gbG9uZ2VzdC5sZW5ndGggPyBuZXh0IDogbG9uZ2VzdCxcXHJcXG4gICAgICAgIC8vIFJldHVybiB0aGUgZmluYWwgcmVzdWx0IGFzIGFuIHVwcGVyIGNhc2Ugc3RyaW5nLlxcclxcbiAgICAgICAgZnJ1aXQgPT4gZnJ1aXQudG9VcHBlckNhc2UoKSk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSBmcnVpdCB3aXRoIHRoZSBsb25nZXN0IG5hbWUgaXMgJHsgbG9uZ2VzdE5hbWUgfWApO1xcclxcblxcclxcbi8vIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG4vL1xcclxcbi8vIFRoZSBmcnVpdCB3aXRoIHRoZSBsb25nZXN0IG5hbWUgaXMgUEFTU0lPTkZSVUlULid9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOicvLyBDcmVhdGUgYW4gYXJyYXkgb2YgUGV0cy5cXHJcXG5sZXQgcGV0cyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDEwIH0sXFxyXFxuICAgIHsgbmFtZTogXCJCb290c1wiLCBhZ2U6IDE0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDYgfVxcclxcbl07XFxyXFxuXFxyXFxuLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIHBldCBuYW1lc1xcclxcbi8vIGluIHRoZSBhcnJheSBzdGFydCB3aXRoIFxcJ0JcXCcuXFxyXFxubGV0IGFsbFN0YXJ0V2l0aEIgPSBwZXRzLmFzRW51bWVyYWJsZSgpLmFsbChwZXQgPT4gcGV0Lm5hbWUuc3RhcnRzV2l0aChcIkJcIikpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGAkeyBhbGxTdGFydFdpdGhCID8gXCJBbGxcIiA6IFwiTm90IGFsbFwiIH0gcGV0IG5hbWVzIHN0YXJ0IHdpdGggXFwnQlxcJy5gKTtcXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyAgTm90IGFsbCBwZXQgbmFtZXMgc3RhcnQgd2l0aCBcXCdCXFwnLicsJzIuanMnOidsZXQgcGVvcGxlID0gW1xcclxcbiAgICB7XFxyXFxuICAgICAgICBsYXN0TmFtZTogXCJIYWFzXCIsXFxyXFxuICAgICAgICBwZXRzOiBbXFxyXFxuICAgICAgICAgICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDEwIH0sXFxyXFxuICAgICAgICAgICAgeyBuYW1lOiBcIkJvb3RzXCIsIGFnZTogMTQgfSxcXHJcXG4gICAgICAgICAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgYWdlOiA2IH1cXHJcXG4gICAgICAgIF1cXHJcXG4gICAgfSxcXHJcXG4gICAge1xcclxcbiAgICAgICAgbGFzdE5hbWU6IFwiRmFraG91cmlcIixcXHJcXG4gICAgICAgIHBldHM6IFtcXHJcXG4gICAgICAgICAgICB7IG5hbWU6IFwiU25vd2JhbGxcIiwgYWdlOiAxIH1cXHJcXG4gICAgICAgIF1cXHJcXG4gICAgfSxcXHJcXG4gICAge1xcclxcbiAgICAgICAgbGFzdE5hbWU6IFwiQW50ZWJpXCIsXFxyXFxuICAgICAgICBwZXRzOiBbXFxyXFxuICAgICAgICAgICAgeyBuYW1lOiBcIkJlbGxlXCIsIGFnZTogOCB9XFxyXFxuICAgICAgICBdXFxyXFxuICAgIH0sXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGxhc3ROYW1lOiBcIlBoaWxpcHNcIixcXHJcXG4gICAgICAgIHBldHM6IFtcXHJcXG4gICAgICAgICAgICB7IG5hbWU6IFwiU3dlZXRpZVwiLCBhZ2U6IDIgfSxcXHJcXG4gICAgICAgICAgICB7IG5hbWU6IFwiUm92ZXJcIiwgYWdlOiAxMyB9XFxyXFxuICAgICAgICBdXFxyXFxuICAgIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIERldGVybWluZSB3aGljaCBwZW9wbGUgaGF2ZSBwZXRzIHRoYXQgYXJlIGFsbCBvbGRlciB0aGFuIDUuXFxyXFxubGV0IG5hbWVzID0gcGVvcGxlLmFzRW51bWVyYWJsZSgpLndoZXJlKHBlcnNvbiA9PiBwZXJzb24ucGV0cy5hbGwocGV0ID0+IHBldC5hZ2UgPiA1KSkuc2VsZWN0KHBlcnNvbiA9PiBwZXJzb24ubGFzdE5hbWUpO1xcclxcblxcclxcbmZvciAobGV0IG5hbWUgb2YgbmFtZXMpIHtcXHJcXG4gICAgY29uc29sZS5sb2cobmFtZSk7XFxyXFxufVxcclxcblxcclxcbi8qIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG4gKlxcclxcbiAqIEhhYXNcXHJcXG4gKiBBbnRlYmlcXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonLy8gQ3JlYXRlIGFuIGFycmF5IG9mIFBldHMuXFxyXFxubGV0IHBldHMgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJCYXJsZXlcIiwgYWdlOiA4LCB2YWNjaW5hdGVkOiB0cnVlIH0sXFxyXFxuICAgIHsgbmFtZTogXCJCb290c1wiLCBhZ2U6IDQsIHZhY2NpbmF0ZWQ6IGZhbHNlIH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEsIHZhY2NpbmF0ZWQ6IGZhbHNlIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIERldGVybWluZSB3aGV0aGVyIGFueSBwZXRzIG92ZXIgYWdlIDEgYXJlIGFsc28gdW52YWNjaW5hdGVkLlxcclxcbmxldCB1bnZhY2NpbmF0ZWQgPSBwZXRzLmFzRW51bWVyYWJsZSgpLmFueShwID0+IHAuYWdlID4gMSAmJiBwLnZhY2NpbmF0ZWQgPT09IGZhbHNlKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhgVGhlcmUgJHsgdW52YWNjaW5hdGVkID8gXCJhcmVcIiA6IFwiYXJlIG5vdCBhbnlcIiB9IHVudmFjY2luYXRlZCBhbmltYWxzIG92ZXIgYWdlIG9uZS5gKTtcXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyAgVGhlcmUgYXJlIHVudmFjY2luYXRlZCBhbmltYWxzIG92ZXIgYWdlIG9uZS4nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IG51bWJlcnMgPSBbIFwiMTAwMDdcIiwgXCIzN1wiLCAyOTk4NDYyMzQyMzUgXTtcXHJcXG5cXHJcXG5sZXQgYXZlcmFnZSA9IG51bWJlcnMuYXNFbnVtZXJhYmxlKCkuYXZlcmFnZSgpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGUgYXZlcmFnZSBpcyAkeyBhdmVyYWdlIH0uYCk7XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gVGhlIGF2ZXJhZ2UgaXMgOTk5NDg3NDgwOTMuJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBjYXRzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIGFnZTogOCB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEgfVxcclxcbl07XFxyXFxuXFxyXFxubGV0IGRvZ3MgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJCb3VuZGVyXCIsIGFnZTogMyB9LFxcclxcbiAgICB7IG5hbWU6IFwiU25vb3B5XCIsIGFnZTogMTQgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkZpZG9cIiwgYWdlOiA5IH1cXHJcXG5dO1xcclxcblxcclxcbmxldCBxdWVyeSA9IGNhdHMuYXNFbnVtZXJhYmxlKCkuc2VsZWN0KGNhdCA9PiBjYXQubmFtZSlcXHJcXG4gICAgLmNvbmNhdChkb2dzLmFzRW51bWVyYWJsZSgpLnNlbGVjdChkb2cgPT4gZG9nLm5hbWUpKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBuYW1lIG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKG5hbWUpO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyBCYXJsZXlcXHJcXG4vLyBCb290c1xcclxcbi8vIFdoaXNrZXJzXFxyXFxuLy8gQm91bmRlclxcclxcbi8vIFNub29weVxcclxcbi8vIEZpZG8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IGZydWl0cyA9IFsgXCJhcHBsZVwiLCBcImJhbmFuYVwiLCBcIm1hbmdvXCIsIFwib3JhbmdlXCIsIFwicGFzc2lvbmZydWl0XCIsIFwiZ3JhcGVcIiBdO1xcclxcblxcclxcbmxldCBmcnVpdCA9IFwibWFuZ29cIjtcXHJcXG5cXHJcXG5sZXQgaGFzTWFuZ28gPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkuY29udGFpbnMoZnJ1aXQpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGUgYXJyYXkgJHsgaGFzTWFuZ28gPyBcImRvZXNcIiA6IFwiZG9lcyBub3RcIiB9IGNvbnRhaW4gXFwnJHsgZnJ1aXQgfVxcJy5gKTtcXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyBUaGUgYXJyYXkgZG9lcyBjb250YWluIFxcJ21hbmdvXFwnLicsJzIuanMnOicvLyBDdXN0b20gY29tcGFyZXIgZm9yIGNvbnRhaW5zXFxyXFxubGV0IHByb2R1Y3RDb21wYXJlciA9ICh4LCB5KSA9PiB7XFxyXFxuICAgIGlmICh4ID09PSB5KSByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgaWYgKCF4IHx8ICF5KSByZXR1cm4gZmFsc2U7XFxyXFxuICAgIC8vIEZydWl0cyBhcmUgZXF1YWwgaWYgdGhlaXIgbmFtZXMgYW5kIHByb2R1Y3QgbnVtYmVycyBhcmUgZXF1YWwuXFxyXFxuICAgIHJldHVybiB4LmNvZGUgPT09IHkuY29kZSAmJiB4Lm5hbWUgPT09IHkubmFtZTtcXHJcXG59O1xcclxcblxcclxcbmxldCBmcnVpdHMgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJhcHBsZVwiLCBjb2RlOiA5IH0sXFxyXFxuICAgIHsgbmFtZTogXCJvcmFuZ2VcIiwgY29kZTogNCB9LFxcclxcbiAgICB7IG5hbWU6IFwibGVtb25cIiwgY29kZTogMTIgfVxcclxcbl07XFxyXFxuXFxyXFxubGV0IGFwcGxlID0geyBuYW1lOiBcImFwcGxlXCIsIGNvZGU6IDkgfTtcXHJcXG5sZXQga2l3aSA9IHsgbmFtZTogXCJraXdpXCIsIGNvZGU6IDggfTtcXHJcXG5cXHJcXG5sZXQgaGFzQXBwbGUgPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkuY29udGFpbnMoYXBwbGUsIHByb2R1Y3RDb21wYXJlcik7XFxyXFxubGV0IGhhc0tpd2kgPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkuY29udGFpbnMoa2l3aSwgcHJvZHVjdENvbXBhcmVyKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhcIkFwcGxlPyBcIiArIGhhc0FwcGxlKTtcXHJcXG5jb25zb2xlLmxvZyhcIktpd2k/IFwiICsgaGFzS2l3aSk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBBcHBsZT8gdHJ1ZVxcclxcbiBLaXdpPyBmYWxzZVxcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJncmFwZVwiIF07XFxyXFxuXFxyXFxubGV0IG51bWJlck9mRnJ1aXRzID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLmNvdW50KCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZXJlIGFyZSAkeyBudW1iZXJPZkZydWl0cyB9IGZydWl0cyBpbiB0aGUgY29sbGVjdGlvbi5gKTtcXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyBUaGVyZSBhcmUgNiBmcnVpdHMgaW4gdGhlIGNvbGxlY3Rpb24uXFxyXFxuJywnMi5qcyc6J2xldCBwZXRzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIHZhY2NpbmF0ZWQ6IHRydWUgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIHZhY2NpbmF0ZWQ6IGZhbHNlIH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCB2YWNjaW5hdGVkOiBmYWxzZSB9XFxyXFxuXTtcXHJcXG5cXHJcXG5sZXQgbnVtYmVyVW52YWNjaW5hdGVkID0gcGV0cy5hc0VudW1lcmFibGUoKS5jb3VudChwID0+IHAudmFjY2luYXRlZCA9PT0gZmFsc2UpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGVyZSBhcmUgJHsgbnVtYmVyVW52YWNjaW5hdGVkIH0gdW52YWNjaW5hdGVkIGFuaW1hbHMuYCk7XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gVGhlcmUgYXJlIDIgdW52YWNjaW5hdGVkIGFuaW1hbHMuJywnMy5qcyc6J2xldCBwZXRzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIHZhY2NpbmF0ZWQ6IHRydWUgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIHZhY2NpbmF0ZWQ6IGZhbHNlIH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCB2YWNjaW5hdGVkOiBmYWxzZSB9XFxyXFxuXTtcXHJcXG5cXHJcXG5sZXQgbnVtYmVyVW52YWNjaW5hdGVkID0gcGV0cy5hc0VudW1lcmFibGUoKS5jb3VudCh7IHZhY2NpbmF0ZWQ6IGZhbHNlIH0pO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGVyZSBhcmUgJHsgbnVtYmVyVW52YWNjaW5hdGVkIH0gdW52YWNjaW5hdGVkIGFuaW1hbHMuYCk7XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gVGhlcmUgYXJlIDIgdW52YWNjaW5hdGVkIGFuaW1hbHMuJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBkZWZhdWx0UGV0ID0geyBuYW1lOiBcIkRlZmF1bHQgUGV0IE5hbWVcIiwgYWdlOiAwIH07XFxyXFxuXFxyXFxubGV0IHBldHMxID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIGFnZTogOCB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEgfVxcclxcbl07XFxyXFxuXFxyXFxuZm9yIChsZXQgcGV0IG9mIHBldHMxLmFzRW51bWVyYWJsZSgpLmRlZmF1bHRJZkVtcHR5KGRlZmF1bHRQZXQpKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGBOYW1lOiAkeyBwZXQubmFtZSB9YCk7XFxyXFxufVxcclxcblxcclxcbmNvbnNvbGUubG9nKCk7XFxyXFxuXFxyXFxubGV0IHBldHMyID0gW107XFxyXFxuXFxyXFxuZm9yIChsZXQgcGV0IG9mIHBldHMyLmFzRW51bWVyYWJsZSgpLmRlZmF1bHRJZkVtcHR5KGRlZmF1bHRQZXQpKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGBOYW1lOiAkeyBwZXQubmFtZSB9YCk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gTmFtZTogQmFybGV5XFxyXFxuIE5hbWU6IEJvb3RzXFxyXFxuIE5hbWU6IFdoaXNrZXJzXFxyXFxuXFxyXFxuIE5hbWU6IERlZmF1bHQgUGV0IE5hbWVcXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IGFnZXMgPSBbIDIxLCA0NiwgNDYsIDU1LCAxNywgMjEsIDU1LCA1NSBdO1xcclxcblxcclxcbmxldCBkaXN0aW5jdEFnZXMgPSBhZ2VzLmFzRW51bWVyYWJsZSgpLmRpc3RpbmN0KCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coXCJEaXN0aW5jdCBhZ2VzOlwiKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBhZ2Ugb2YgZGlzdGluY3RBZ2VzKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGFnZSk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gRGlzdGluY3QgYWdlczpcXHJcXG4gMjFcXHJcXG4gNDZcXHJcXG4gNTVcXHJcXG4gMTdcXHJcXG4gKi9cXHJcXG4nLCcyLmpzJzonLy8gQ3VzdG9tIGNvbXBhcmVyIGZvciBkaXN0aW5jdFxcclxcbmxldCBwcm9kdWN0Q29tcGFyZXIgPSAoeCwgeSkgPT4ge1xcclxcbiAgICBpZiAoeCA9PT0geSkgcmV0dXJuIHRydWU7XFxyXFxuICAgIGlmICgheCB8fCAheSkgcmV0dXJuIGZhbHNlO1xcclxcbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBwcm9kdWN0c1xcJyBwcm9wZXJ0aWVzIGFyZSBlcXVhbC5cXHJcXG4gICAgcmV0dXJuIHguY29kZSA9PT0geS5jb2RlICYmIHgubmFtZSA9PT0geS5uYW1lO1xcclxcbn07XFxyXFxuXFxyXFxubGV0IHByb2R1Y3RzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiYXBwbGVcIiwgY29kZTogOSB9LFxcclxcbiAgICB7IG5hbWU6IFwib3JhbmdlXCIsIGNvZGU6IDQgfSxcXHJcXG4gICAgeyBuYW1lOiBcImFwcGxlXCIsIGNvZGU6IDkgfSxcXHJcXG4gICAgeyBuYW1lOiBcImxlbW9uXCIsIGNvZGU6IDEyIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIEV4Y2x1ZGUgZHVwbGljYXRlcy5cXHJcXG5sZXQgbm9kdXBsaWNhdGVzID0gcHJvZHVjdHMuZGlzdGluY3QocHJvZHVjdENvbXBhcmVyKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBwcm9kdWN0IG9mIG5vZHVwbGljYXRlcykge1xcclxcbiAgICBjb25zb2xlLmxvZyhwcm9kdWN0Lm5hbWUgKyBcIiBcIiArIHByb2R1Y3QuY29kZSk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gYXBwbGUgOVxcclxcbiBvcmFuZ2UgNFxcclxcbiBsZW1vbiAxMlxcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgbmFtZXMgPSBbIFwiSGFydG9ubywgVG9tbXlcIiwgXCJBZGFtcywgVGVycnlcIiwgXCJBbmRlcnNlbiwgSGVucmlldHRlIFRoYXVsb3dcIiwgXCJIZWRsdW5kLCBNYWdudXNcIiwgXCJJdG8sIFNodVwiIF07XFxyXFxuXFxyXFxubGV0IG5hbWUgPSBuYW1lcy5hc0VudW1lcmFibGUoKS5lbGVtZW50QXQoNCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSBuYW1lIGlzIFxcJyR7IG5hbWUgfVxcJy5gKTtcXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFRoZSBuYW1lIGlzIFxcJ0l0bywgU2h1XFwnLlxcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgbmFtZXMgPSBbIFwiSGFydG9ubywgVG9tbXlcIiwgXCJBZGFtcywgVGVycnlcIiwgXCJBbmRlcnNlbiwgSGVucmlldHRlIFRoYXVsb3dcIiwgXCJIZWRsdW5kLCBNYWdudXNcIiwgXCJJdG8sIFNodVwiIF07XFxyXFxuXFxyXFxubGV0IGluZGV4ID0gMjA7XFxyXFxuXFxyXFxubGV0IG5hbWUgPSBuYW1lcy5hc0VudW1lcmFibGUoKS5lbGVtZW50QXRPckRlZmF1bHQoaW5kZXgsIFwiW25vIG5hbWUgYXQgdGhpcyBpbmRleF1cIik7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSBuYW1lIGNob3NlbiBhdCBpbmRleCAkeyBpbmRleCB9IGlzIFxcJyR7IG5hbWUgfVxcJy5gKTtcXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFRoZSBuYW1lIGNob3NlbiBhdCBpbmRleCAyMCBpcyBcXCdbbm8gbmFtZSBhdCB0aGlzIGluZGV4XVxcJy5cXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IG51bWJlcnMxID0gWyAyLjAsIDIuMCwgMi4xLCAyLjIsIDIuMywgMi4zLCAyLjQsIDIuNSBdO1xcclxcbmxldCBudW1iZXJzMiA9IFsgMi4yIF07XFxyXFxuXFxyXFxubGV0IG9ubHlJbkZpcnN0U2V0ID0gbnVtYmVyczEuYXNFbnVtZXJhYmxlKCkuZXhjZXB0KG51bWJlcnMyKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBudW1iZXIgb2Ygb25seUluRmlyc3RTZXQpIHtcXHJcXG4gICAgY29uc29sZS5sb2cobnVtYmVyKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiAyXFxyXFxuIDIuMVxcclxcbiAyLjNcXHJcXG4gMi40XFxyXFxuIDIuNVxcclxcbiAqLycsJzIuanMnOicvLyBDdXN0b20gY29tcGFyZXIgZm9yIGRpc3RpbmN0XFxyXFxubGV0IHByb2R1Y3RDb21wYXJlciA9ICh4LCB5KSA9PiB7XFxyXFxuICAgIGlmICh4ID09PSB5KSByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgaWYgKCF4IHx8ICF5KSByZXR1cm4gZmFsc2U7XFxyXFxuICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHByb2R1Y3RzXFwnIHByb3BlcnRpZXMgYXJlIGVxdWFsLlxcclxcbiAgICByZXR1cm4geC5jb2RlID09PSB5LmNvZGUgJiYgeC5uYW1lID09PSB5Lm5hbWU7XFxyXFxufTtcXHJcXG5cXHJcXG5sZXQgZnJ1aXRzMSA9IFtcXHJcXG4gICAgeyBuYW1lOiBcImFwcGxlXCIsIGNvZGU6IDkgfSxcXHJcXG4gICAgeyBuYW1lOiBcIm9yYW5nZVwiLCBjb2RlOiA0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJsZW1vblwiLCBjb2RlOiAxMiB9XFxyXFxuXTtcXHJcXG5cXHJcXG5sZXQgZnJ1aXRzMiA9IFsgeyBuYW1lOiBcImFwcGxlXCIsIGNvZGU6IDkgfSBdO1xcclxcblxcclxcbi8vR2V0IGFsbCB0aGUgZWxlbWVudHMgZnJvbSB0aGUgZmlyc3QgYXJyYXlcXHJcXG4vL2V4Y2VwdCBmb3IgdGhlIGVsZW1lbnRzIGZyb20gdGhlIHNlY29uZCBhcnJheS5cXHJcXG5sZXQgZXhjZXB0ID0gZnJ1aXRzMS5hc0VudW1lcmFibGUoKS5leGNlcHQoZnJ1aXRzMiwgcHJvZHVjdENvbXBhcmVyKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBwcm9kdWN0IG9mIGV4Y2VwdCkge1xcclxcbiAgICBjb25zb2xlLmxvZyhwcm9kdWN0Lm5hbWUgKyBcIiBcIiArIHByb2R1Y3QuY29kZSk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gb3JhbmdlIDRcXHJcXG4gbGVtb24gMTJcXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IG51bWJlcnMgPSBbIDksIDM0LCA2NSwgOTIsIDg3LCA0MzUsIDMsIDU0LCA4MywgMjMsIDg3LCA0MzUsIDY3LCAxMiwgMTkgXTtcXHJcXG5cXHJcXG5sZXQgZmlyc3QgPSBudW1iZXJzLmFzRW51bWVyYWJsZSgpLmZpcnN0KCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coZmlyc3QpO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gOVxcclxcbiAqLycsJzIuanMnOidsZXQgbnVtYmVycyA9IFsgOSwgMzQsIDY1LCA5MiwgODcsIDQzNSwgMywgNTQsIDgzLCAyMywgODcsIDQzNSwgNjcsIDEyLCAxOSBdO1xcclxcblxcclxcbmxldCBmaXJzdCA9IG51bWJlcnMuYXNFbnVtZXJhYmxlKCkuZmlyc3QobnVtYmVyID0+IG51bWJlciA+IDgwKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhmaXJzdCk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiA5MlxcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgbnVtYmVycyA9IFtdO1xcclxcbmxldCBmaXJzdCA9IG51bWJlcnMuYXNFbnVtZXJhYmxlKCkuZmlyc3RPckRlZmF1bHQoMCk7XFxyXFxuY29uc29sZS5sb2coZmlyc3QpO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gMFxcclxcbiAqLycsJzIuanMnOidsZXQgbmFtZXMgPSBbIFwiSGFydG9ubywgVG9tbXlcIiwgXCJBZGFtcywgVGVycnlcIixcXHJcXG4gICAgXCJBbmRlcnNlbiwgSGVucmlldHRlIFRoYXVsb3dcIixcXHJcXG4gICAgXCJIZWRsdW5kLCBNYWdudXNcIiwgXCJJdG8sIFNodVwiIF07XFxyXFxuXFxyXFxubGV0IGZpcnN0TG9uZ05hbWUgPSBuYW1lcy5hc0VudW1lcmFibGUoKS5maXJzdE9yRGVmYXVsdChcIlwiLCBuYW1lID0+IG5hbWUubGVuZ3RoID4gMjApO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGUgZmlyc3QgbG9uZyBuYW1lIGlzICR7IGZpcnN0TG9uZ05hbWUgfS5gKTtcXHJcXG5cXHJcXG5sZXQgZmlyc3RWZXJ5TG9uZ05hbWUgPSBuYW1lcy5hc0VudW1lcmFibGUoKS5maXJzdE9yRGVmYXVsdChcIlwiLCBuYW1lID0+IG5hbWUubGVuZ3RoID4gMzApO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGVyZSBpcyAkeyBmaXJzdFZlcnlMb25nTmFtZSA9PT0gXCJcIiA/IFwibm90IGFcIiA6IFwiYVwiIH0gbmFtZSBsb25nZXIgdGhhbiAzMCBjaGFyYWN0ZXJzLmApO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gVGhlIGZpcnN0IGxvbmcgbmFtZSBpcyBcXCdBbmRlcnNlbiwgSGVucmlldHRlIFRoYXVsb3dcXCcuXFxyXFxuIFRoZXJlIGlzIG5vdCBhIG5hbWUgbG9uZ2VyIHRoYW4gMzAgY2hhcmFjdGVycy5cXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonLy8gQ3JlYXRlIGEgbGlzdCBvZiBwZXRzLlxcclxcbmxldCBwZXRzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIGFnZTogOCB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkRhaXN5XCIsIGFnZTogNCB9XFxyXFxuXTtcXHJcXG5cXHJcXG4vLyBHcm91cCB0aGUgcGV0cyB1c2luZyBBZ2UgYXMgdGhlIGtleSB2YWx1ZVxcclxcbi8vIGFuZCBzZWxlY3Rpbmcgb25seSB0aGUgcGV0XFwncyBOYW1lIGZvciBlYWNoIHZhbHVlLlxcclxcbmxldCBxdWVyeSA9IHBldHMuYXNFbnVtZXJhYmxlKCkuZ3JvdXBCeShwZXQgPT4gcGV0LmFnZSwgcGV0ID0+IHBldC5uYW1lKTtcXHJcXG5cXHJcXG4vLyBJdGVyYXRlIG92ZXIgZWFjaCBJR3JvdXBpbmcgaW4gdGhlIGNvbGxlY3Rpb24uXFxyXFxuZm9yIChsZXQgcGV0R3JvdXAgb2YgcXVlcnkpIHtcXHJcXG4gICAgLy8gUHJpbnQgdGhlIGtleSB2YWx1ZSBvZiB0aGUgSUdyb3VwaW5nLlxcclxcbiAgICBjb25zb2xlLmxvZyhwZXRHcm91cC5rZXkpO1xcclxcbiAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCB2YWx1ZSBpbiB0aGVcXHJcXG4gICAgLy8gSUdyb3VwaW5nIGFuZCBwcmludCB0aGUgdmFsdWUuXFxyXFxuICAgIGZvciAobGV0IG5hbWUgb2YgcGV0R3JvdXApXFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhgICAkeyBuYW1lIH1gKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiA4XFxyXFxuICAgQmFybGV5XFxyXFxuIDRcXHJcXG4gICBCb290c1xcclxcbiAgIERhaXN5XFxyXFxuIDFcXHJcXG4gICBXaGlza2Vyc1xcclxcbiAqLycsJzItMi4xLjE5LmpzJzonLy8gQ3JlYXRlIGEgbGlzdCBvZiBwZXRzLlxcclxcbmxldCBwZXRzTGlzdCA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDguMyB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0LjkgfSxcXHJcXG4gICAgeyBuYW1lOiBcIldoaXNrZXJzXCIsIGFnZTogMS41IH0sXFxyXFxuICAgIHsgbmFtZTogXCJEYWlzeVwiLCBhZ2U6IDQuMyB9XFxyXFxuXTtcXHJcXG5cXHJcXG4vLyBHcm91cCBQZXQgb2JqZWN0cyBieSB0aGUgTWF0aC5GbG9vciBvZiB0aGVpciBhZ2UuXFxyXFxuLy8gVGhlbiBwcm9qZWN0IGFuIGFub255bW91cyB0eXBlIGZyb20gZWFjaCBncm91cFxcclxcbi8vIHRoYXQgY29uc2lzdHMgb2YgdGhlIGtleSwgdGhlIGNvdW50IG9mIHRoZSBncm91cFxcJ3NcXHJcXG4vLyBlbGVtZW50cywgYW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGFnZSBpbiB0aGUgZ3JvdXAuXFxyXFxubGV0IHF1ZXJ5ID0gcGV0c0xpc3QuYXNFbnVtZXJhYmxlKCkuZ3JvdXBCeShcXHJcXG4gICAgcGV0ID0+IE1hdGguZmxvb3IocGV0LmFnZSksXFxyXFxuICAgIHBldCA9PiBwZXQsXFxyXFxuICAgIChhZ2UsIHBldHMpID0+ICh7XFxyXFxuICAgICAgICBrZXk6IGFnZSxcXHJcXG4gICAgICAgIGNvdW50OiBwZXRzLmNvdW50KCksXFxyXFxuICAgICAgICBtaW46IHBldHMubWluKHBldCA9PiBwZXQuYWdlKSxcXHJcXG4gICAgICAgIG1heDogcGV0cy5tYXgocGV0ID0+IHBldC5hZ2UpXFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4vLyBJdGVyYXRlIG92ZXIgZWFjaCBhbm9ueW1vdXMgdHlwZS5cXHJcXG5mb3IgKGxldCByZXN1bHQgb2YgcXVlcnkpIHtcXHJcXG4gICAgY29uc29sZS5sb2coXCJcXFxcbkFnZSBncm91cDogXCIgKyByZXN1bHQua2V5KTtcXHJcXG4gICAgY29uc29sZS5sb2coXCJOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogXCIgKyByZXN1bHQuY291bnQpO1xcclxcbiAgICBjb25zb2xlLmxvZyhcIk1pbmltdW0gYWdlOiBcIiArIHJlc3VsdC5taW4pO1xcclxcbiAgICBjb25zb2xlLmxvZyhcIk1heGltdW0gYWdlOiBcIiArIHJlc3VsdC5tYXgpO1xcclxcbn1cXHJcXG5cXHJcXG4vKiAgVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBBZ2UgZ3JvdXA6IDhcXHJcXG4gTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IDFcXHJcXG4gTWluaW11bSBhZ2U6IDguM1xcclxcbiBNYXhpbXVtIGFnZTogOC4zXFxyXFxuXFxyXFxuIEFnZSBncm91cDogNFxcclxcbiBOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogMlxcclxcbiBNaW5pbXVtIGFnZTogNC4zXFxyXFxuIE1heGltdW0gYWdlOiA0LjlcXHJcXG5cXHJcXG4gQWdlIGdyb3VwOiAxXFxyXFxuIE51bWJlciBvZiBwZXRzIGluIHRoaXMgYWdlIGdyb3VwOiAxXFxyXFxuIE1pbmltdW0gYWdlOiAxLjVcXHJcXG4gTWF4aW11bSBhZ2U6IDEuNVxcclxcbiAqLycsJzIuanMnOicvLyBDcmVhdGUgYSBsaXN0IG9mIHBldHMuXFxyXFxubGV0IHBldHNMaXN0ID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIGFnZTogOC4zIH0sXFxyXFxuICAgIHsgbmFtZTogXCJCb290c1wiLCBhZ2U6IDQuOSB9LFxcclxcbiAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgYWdlOiAxLjUgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkRhaXN5XCIsIGFnZTogNC4zIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIEdyb3VwIFBldCBvYmplY3RzIGJ5IHRoZSBNYXRoLkZsb29yIG9mIHRoZWlyIGFnZS5cXHJcXG4vLyBUaGVuIHByb2plY3QgYW4gYW5vbnltb3VzIHR5cGUgZnJvbSBlYWNoIGdyb3VwXFxyXFxuLy8gdGhhdCBjb25zaXN0cyBvZiB0aGUga2V5LCB0aGUgY291bnQgb2YgdGhlIGdyb3VwXFwncyBlbGVtZW50cy5cXHJcXG5sZXQgcXVlcnkgPSBwZXRzTGlzdC5hc0VudW1lcmFibGUoKS5ncm91cEJ5KFxcclxcbiAgICBwZXQgPT4gTWF0aC5mbG9vcihwZXQuYWdlKSxcXHJcXG4gICAgcGV0ID0+IHBldCxcXHJcXG4gICAgKGFnZSwgcGV0cykgPT4gKHtcXHJcXG4gICAgICAgIGtleTogYWdlLFxcclxcbiAgICAgICAgY291bnQ6IHBldHMuY291bnQoKVxcclxcbiAgICB9KSk7XFxyXFxuXFxyXFxuLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYW5vbnltb3VzIHR5cGUuXFxyXFxuZm9yIChsZXQgcmVzdWx0IG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKFwiXFxcXG5BZ2UgZ3JvdXA6IFwiICsgcmVzdWx0LmtleSk7XFxyXFxuICAgIGNvbnNvbGUubG9nKFwiTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IFwiICsgcmVzdWx0LmNvdW50KTtcXHJcXG59XFxyXFxuXFxyXFxuLyogIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gQWdlIGdyb3VwOiA4XFxyXFxuIE51bWJlciBvZiBwZXRzIGluIHRoaXMgYWdlIGdyb3VwOiAxXFxyXFxuXFxyXFxuIEFnZSBncm91cDogNFxcclxcbiBOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogMlxcclxcblxcclxcbiBBZ2UgZ3JvdXA6IDFcXHJcXG4gTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IDFcXHJcXG4gKi8nLCczLTIuMS4xOS5qcyc6Jy8vIENyZWF0ZSBhIGxpc3Qgb2YgcGV0cy5cXHJcXG5sZXQgcGV0c0xpc3QgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJCYXJsZXlcIiwgYWdlOiA4LjMgfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIGFnZTogNC45IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEuNSB9LFxcclxcbiAgICB7IG5hbWU6IFwiRGFpc3lcIiwgYWdlOiA0LjMgfVxcclxcbl07XFxyXFxuXFxyXFxuLy8gR3JvdXAgUGV0IG9iamVjdHMgYnkgdGhlIE1hdGguRmxvb3Igb2YgdGhlaXIgYWdlLlxcclxcbi8vIFRoZW4gcHJvamVjdCBhbiBhbm9ueW1vdXMgdHlwZSBmcm9tIGVhY2ggZ3JvdXBcXHJcXG4vLyB0aGF0IGNvbnNpc3RzIG9mIHRoZSBrZXksIHRoZSBjb3VudCBvZiB0aGUgZ3JvdXBcXCdzXFxyXFxuLy8gZWxlbWVudHMsIGFuZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBhZ2UgaW4gdGhlIGdyb3VwLlxcclxcbmxldCBxdWVyeSA9IHBldHNMaXN0LmFzRW51bWVyYWJsZSgpLmdyb3VwQnkoXFxyXFxuICAgIHBldCA9PiBNYXRoLmZsb29yKHBldC5hZ2UpLFxcclxcbiAgICBwZXQgPT4gcGV0LmFnZSxcXHJcXG4gICAgKGFnZSwgYWdlcykgPT4gKHtcXHJcXG4gICAgICAgIGtleTogYWdlLFxcclxcbiAgICAgICAgY291bnQ6IGFnZXMuY291bnQoKSxcXHJcXG4gICAgICAgIG1pbjogYWdlcy5taW4oKSxcXHJcXG4gICAgICAgIG1heDogYWdlcy5tYXgoKVxcclxcbiAgICB9KSk7XFxyXFxuXFxyXFxuLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYW5vbnltb3VzIHR5cGUuXFxyXFxuZm9yIChsZXQgcmVzdWx0IG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKFwiXFxcXG5BZ2UgZ3JvdXA6IFwiICsgcmVzdWx0LmtleSk7XFxyXFxuICAgIGNvbnNvbGUubG9nKFwiTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IFwiICsgcmVzdWx0LmNvdW50KTtcXHJcXG4gICAgY29uc29sZS5sb2coXCJNaW5pbXVtIGFnZTogXCIgKyByZXN1bHQubWluKTtcXHJcXG4gICAgY29uc29sZS5sb2coXCJNYXhpbXVtIGFnZTogXCIgKyByZXN1bHQubWF4KTtcXHJcXG59XFxyXFxuXFxyXFxuLyogIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gQWdlIGdyb3VwOiA4XFxyXFxuIE51bWJlciBvZiBwZXRzIGluIHRoaXMgYWdlIGdyb3VwOiAxXFxyXFxuIE1pbmltdW0gYWdlOiA4LjNcXHJcXG4gTWF4aW11bSBhZ2U6IDguM1xcclxcblxcclxcbiBBZ2UgZ3JvdXA6IDRcXHJcXG4gTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IDJcXHJcXG4gTWluaW11bSBhZ2U6IDQuM1xcclxcbiBNYXhpbXVtIGFnZTogNC45XFxyXFxuXFxyXFxuIEFnZSBncm91cDogMVxcclxcbiBOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogMVxcclxcbiBNaW5pbXVtIGFnZTogMS41XFxyXFxuIE1heGltdW0gYWdlOiAxLjVcXHJcXG4gKi8nLCczLmpzJzonLy8gQ3JlYXRlIGEgbGlzdCBvZiBwZXRzLlxcclxcbmxldCBwZXRzTGlzdCA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDguMyB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0LjkgfSxcXHJcXG4gICAgeyBuYW1lOiBcIldoaXNrZXJzXCIsIGFnZTogMS41IH0sXFxyXFxuICAgIHsgbmFtZTogXCJEYWlzeVwiLCBhZ2U6IDQuMyB9XFxyXFxuXTtcXHJcXG5cXHJcXG4vLyBHcm91cCBQZXQgb2JqZWN0cyBieSB0aGUgTWF0aC5GbG9vciBvZiB0aGVpciBhZ2UuXFxyXFxuLy8gVGhlbiBwcm9qZWN0IGFuIGFub255bW91cyB0eXBlIGZyb20gZWFjaCBncm91cFxcclxcbi8vIHRoYXQgY29uc2lzdHMgb2YgdGhlIGtleSwgdGhlIGNvdW50IG9mIHRoZSBncm91cFxcJ3NcXHJcXG4vLyBlbGVtZW50cywgYW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGFnZSBpbiB0aGUgZ3JvdXAuXFxyXFxubGV0IHF1ZXJ5ID0gcGV0c0xpc3QuYXNFbnVtZXJhYmxlKCkuZ3JvdXBCeShcXHJcXG4gICAgcGV0ID0+IE1hdGguZmxvb3IocGV0LmFnZSksXFxyXFxuICAgIHBldCA9PiBwZXQuYWdlLFxcclxcbiAgICAoYWdlLCBhZ2VzKSA9PiAoe1xcclxcbiAgICAgICAga2V5OiBhZ2UsXFxyXFxuICAgICAgICBjb3VudDogYWdlcy5jb3VudCgpXFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4vLyBJdGVyYXRlIG92ZXIgZWFjaCBhbm9ueW1vdXMgdHlwZS5cXHJcXG5mb3IgKGxldCByZXN1bHQgb2YgcXVlcnkpIHtcXHJcXG4gICAgY29uc29sZS5sb2coXCJcXFxcbkFnZSBncm91cDogXCIgKyByZXN1bHQua2V5KTtcXHJcXG4gICAgY29uc29sZS5sb2coXCJOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogXCIgKyByZXN1bHQuY291bnQpXFxyXFxufVxcclxcblxcclxcbi8qICBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIEFnZSBncm91cDogOFxcclxcbiBOdW1iZXIgb2YgcGV0cyBpbiB0aGlzIGFnZSBncm91cDogMVxcclxcblxcclxcbiBBZ2UgZ3JvdXA6IDRcXHJcXG4gTnVtYmVyIG9mIHBldHMgaW4gdGhpcyBhZ2UgZ3JvdXA6IDJcXHJcXG5cXHJcXG4gQWdlIGdyb3VwOiAxXFxyXFxuIE51bWJlciBvZiBwZXRzIGluIHRoaXMgYWdlIGdyb3VwOiAxXFxyXFxuICovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBtYWdudXMgPSB7IG5hbWU6IFwiSGVkbHVuZCwgTWFnbnVzXCIgfTtcXHJcXG5sZXQgdGVycnkgPSB7IG5hbWU6IFwiQWRhbXMsIFRlcnJ5XCIgfTtcXHJcXG5sZXQgY2hhcmxvdHRlID0geyBuYW1lOiBcIldlaXNzLCBDaGFybG90dGVcIiB9O1xcclxcblxcclxcbmxldCBiYXJsZXkgPSB7IG5hbWU6IFwiQmFybGV5XCIsIG93bmVyOiB0ZXJyeSB9O1xcclxcbmxldCBib290cyA9IHsgbmFtZTogXCJCb290c1wiLCBvd25lcjogdGVycnkgfTtcXHJcXG5sZXQgd2hpc2tlcnMgPSB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgb3duZXI6IGNoYXJsb3R0ZSB9O1xcclxcbmxldCBkYWlzeSA9IHsgbmFtZTogXCJEYWlzeVwiLCBvd25lcjogbWFnbnVzIH07XFxyXFxuXFxyXFxubGV0IHBlb3BsZSA9IFsgbWFnbnVzLCB0ZXJyeSwgY2hhcmxvdHRlIF07XFxyXFxubGV0IHBldHMgPSBbIGJhcmxleSwgYm9vdHMsIHdoaXNrZXJzLCBkYWlzeSBdO1xcclxcblxcclxcbi8vIENyZWF0ZSBhIGxpc3Qgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGFuIGFub255bW91c1xcclxcbi8vIHR5cGUgdGhhdCBjb250YWlucyBhIHBlcnNvblxcJ3MgbmFtZSBhbmRcXHJcXG4vLyBhIGNvbGxlY3Rpb24gb2YgbmFtZXMgb2YgdGhlIHBldHMgdGhleSBvd24uXFxyXFxubGV0IHF1ZXJ5ID0gcGVvcGxlLmFzRW51bWVyYWJsZSgpLmdyb3VwSm9pbihwZXRzLFxcclxcbiAgICAocGVyc29uLCBwZXRDb2xsZWN0aW9uKSA9PiAoe1xcclxcbiAgICAgICAgb3duZXJOYW1lOiBwZXJzb24ubmFtZSxcXHJcXG4gICAgICAgIHBldHM6IHBldENvbGxlY3Rpb24uc2VsZWN0KHBldCA9PiBwZXQubmFtZSlcXHJcXG4gICAgfSksXFxyXFxuICAgIHBlcnNvbiA9PiBwZXJzb24sXFxyXFxuICAgIHBldCA9PiBwZXQub3duZXIpO1xcclxcblxcclxcbmZvciAobGV0IG9iaiBvZiBxdWVyeSkge1xcclxcbiAgICAvLyBPdXRwdXQgdGhlIG93bmVyXFwncyBuYW1lLlxcclxcbiAgICBjb25zb2xlLmxvZyhgJHsgb2JqLm93bmVyTmFtZSB9OmApO1xcclxcbiAgICAvLyBPdXRwdXQgZWFjaCBvZiB0aGUgb3duZXJcXCdzIHBldFxcJ3MgbmFtZXMuXFxyXFxuICAgIGZvciAobGV0IHBldCBvZiBvYmoucGV0cykge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coYCAgJHsgcGV0IH1gKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIEhlZGx1bmQsIE1hZ251czpcXHJcXG4gICBEYWlzeVxcclxcbiBBZGFtcywgVGVycnk6XFxyXFxuICAgQmFybGV5XFxyXFxuICAgQm9vdHNcXHJcXG4gV2Vpc3MsIENoYXJsb3R0ZTpcXHJcXG4gICBXaGlza2Vyc1xcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgaWQxID0gWyA0NCwgMjYsIDkyLCAzMCwgNzEsIDM4IF07XFxyXFxubGV0IGlkMiA9IFsgMzksIDU5LCA4MywgNDcsIDI2LCA0LCAzMCBdO1xcclxcblxcclxcbmxldCBib3RoID0gaWQxLmFzRW51bWVyYWJsZSgpLmludGVyc2VjdChpZDIpO1xcclxcblxcclxcbmZvciAobGV0IGlkIG9mIGJvdGgpIHtcXHJcXG4gICAgY29uc29sZS5sb2coaWQpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIDI2XFxyXFxuIDMwXFxyXFxuICovJywnMi5qcyc6Jy8vIEN1c3RvbSBjb21wYXJlciBmb3IgZGlzdGluY3RcXHJcXG5sZXQgcHJvZHVjdENvbXBhcmVyID0gKHgsIHkpID0+IHtcXHJcXG4gICAgaWYgKHggPT09IHkpIHJldHVybiB0cnVlO1xcclxcbiAgICBpZiAoIXggfHwgIXkpIHJldHVybiBmYWxzZTtcXHJcXG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcHJvZHVjdHNcXCcgcHJvcGVydGllcyBhcmUgZXF1YWwuXFxyXFxuICAgIHJldHVybiB4LmNvZGUgPT09IHkuY29kZSAmJiB4Lm5hbWUgPT09IHkubmFtZTtcXHJcXG59O1xcclxcblxcclxcbmxldCBzdG9yZTEgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJhcHBsZVwiLCBjb2RlOiA5IH0sXFxyXFxuICAgIHsgbmFtZTogXCJvcmFuZ2VcIiwgY29kZTogNCB9XFxyXFxuXTtcXHJcXG5sZXQgc3RvcmUyID0gW1xcclxcbiAgICB7IG5hbWU6IFwiYXBwbGVcIiwgY29kZTogOSB9LFxcclxcbiAgICB7IG5hbWU6IFwibGVtb25cIiwgY29kZTogMTIgfVxcclxcbl07XFxyXFxuXFxyXFxuLy8gR2V0IHRoZSBwcm9kdWN0cyBmcm9tIHRoZSBmaXJzdCBhcnJheVxcclxcbi8vIHRoYXQgaGF2ZSBkdXBsaWNhdGVzIGluIHRoZSBzZWNvbmQgYXJyYXkuXFxyXFxubGV0IGR1cGxpY2F0ZXMgPSBzdG9yZTEuYXNFbnVtZXJhYmxlKCkuaW50ZXJzZWN0KHN0b3JlMiwgcHJvZHVjdENvbXBhcmVyKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBwcm9kdWN0IG9mIGR1cGxpY2F0ZXMpIHtcXHJcXG4gICAgY29uc29sZS5sb2cocHJvZHVjdC5uYW1lICsgXCIgXCIgKyBwcm9kdWN0LmNvZGUpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIGFwcGxlIDlcXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLjEuanMnOidsZXQgbWFnbnVzID0geyBuYW1lOiBcIkhlZGx1bmQsIE1hZ251c1wiIH07XFxyXFxubGV0IHRlcnJ5ID0geyBuYW1lOiBcIkFkYW1zLCBUZXJyeVwiIH07XFxyXFxubGV0IGNoYXJsb3R0ZSA9IHsgbmFtZTogXCJXZWlzcywgQ2hhcmxvdHRlXCIgfTtcXHJcXG5cXHJcXG5sZXQgYmFybGV5ID0geyBuYW1lOiBcIkJhcmxleVwiLCBvd25lcjogdGVycnkgfTtcXHJcXG5sZXQgYm9vdHMgPSB7IG5hbWU6IFwiQm9vdHNcIiwgb3duZXI6IHRlcnJ5IH07XFxyXFxubGV0IHdoaXNrZXJzID0geyBuYW1lOiBcIldoaXNrZXJzXCIsIG93bmVyOiBjaGFybG90dGUgfTtcXHJcXG5sZXQgZGFpc3kgPSB7IG5hbWU6IFwiRGFpc3lcIiwgb3duZXI6IG1hZ251cyB9O1xcclxcblxcclxcbmxldCBwZW9wbGUgPSBbIG1hZ251cywgdGVycnksIGNoYXJsb3R0ZSBdO1xcclxcbmxldCBwZXRzID0gWyBiYXJsZXksIGJvb3RzLCB3aGlza2VycywgZGFpc3kgXTtcXHJcXG5cXHJcXG4vLyBDcmVhdGUgYSBsaXN0IG9mIFBlcnNvbi1QZXQgcGFpcnMgd2hlcmVcXHJcXG4vLyBlYWNoIGVsZW1lbnQgaXMgYW4gYW5vbnltb3VzIHR5cGUgdGhhdCBjb250YWlucyBhXFxyXFxuLy8gUGV0XFwncyBuYW1lIGFuZCB0aGUgbmFtZSBvZiB0aGUgUGVyc29uIHRoYXQgb3ducyB0aGUgUGV0LlxcclxcbmxldCBxdWVyeSA9IHBlb3BsZS5hc0VudW1lcmFibGUoKS5qb2luKHBldHMsXFxyXFxuICAgIChwZXJzb24sIHBldCkgPT4gKHsgb3duZXJOYW1lOiBwZXJzb24ubmFtZSwgcGV0OiBwZXQubmFtZSB9KSxcXHJcXG4gICAgcGVyc29uID0+IHBlcnNvbixcXHJcXG4gICAgcGV0ID0+IHBldC5vd25lcik7XFxyXFxuXFxyXFxuZm9yIChsZXQgb2JqIG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGAkeyBvYmoub3duZXJOYW1lIH0gLSAkeyBvYmoucGV0IH1gKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBIZWRsdW5kLCBNYWdudXMgLSBEYWlzeVxcclxcbiBBZGFtcywgVGVycnkgLSBCYXJsZXlcXHJcXG4gQWRhbXMsIFRlcnJ5IC0gQm9vdHNcXHJcXG4gV2Vpc3MsIENoYXJsb3R0ZSAtIFdoaXNrZXJzXFxyXFxuICovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBsb25ncyA9IFsgNDI5NDk2NzI5NiwgNDY2ODU1MTM1LCA4MTEyNSBdO1xcclxcblxcclxcbmxldCBtYXggPSBsb25ncy5hc0VudW1lcmFibGUoKS5tYXgoKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhgVGhlIGxhcmdlc3QgbnVtYmVyIGlzICR7IG1heCB9LmApO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gVGhlIGxhcmdlc3QgbnVtYmVyIGlzIDQyOTQ5NjcyOTYuXFxyXFxuICovJywnMi5qcyc6J2xldCBwZXRzID0gW1xcclxcbiAgICB7IG5hbWU6IFwiQmFybGV5XCIsIGFnZTogOCB9LFxcclxcbiAgICB7IG5hbWU6IFwiQm9vdHNcIiwgYWdlOiA0IH0sXFxyXFxuICAgIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEgfVxcclxcbl07XFxyXFxuXFxyXFxubGV0IG1heCA9IHBldHMuYXNFbnVtZXJhYmxlKCkubWF4KHBldCA9PiBwZXQuYWdlICsgcGV0Lm5hbWUubGVuZ3RoKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhgVGhlIG1heGltdW0gcGV0IGFnZSBwbHVzIG5hbWUgbGVuZ3RoIGlzICR7IG1heCB9LmApO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gVGhlIG1heGltdW0gcGV0IGFnZSBwbHVzIG5hbWUgbGVuZ3RoIGlzIDE0LlxcclxcbiAqLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgbG9uZ3MgPSBbIDQyOTQ5NjcyOTYsIDQ2Njg1NTEzNSwgODExMjUgXTtcXHJcXG5cXHJcXG5sZXQgbWluID0gbG9uZ3MuYXNFbnVtZXJhYmxlKCkubWluKCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSBzbWFsbGVzdCBudW1iZXIgaXMgJHsgbWluIH0uYCk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBUaGUgc21hbGxlc3QgbnVtYmVyIGlzIDgxMTI1LlxcclxcbiAqLycsJzIuanMnOidsZXQgcGV0cyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDggfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIGFnZTogNCB9LFxcclxcbiAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgYWdlOiAxIH1cXHJcXG5dO1xcclxcblxcclxcbmxldCBtaW4gPSBwZXRzLmFzRW51bWVyYWJsZSgpLm1pbihwZXQgPT4gcGV0LmFnZSk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSB5b3VuZ2VzdCBhbmltYWwgaXMgYWdlICR7IG1pbiB9LmApO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gVGhlIHlvdW5nZXN0IGFuaW1hbCBpcyBhZ2UgNS5cXHJcXG4gKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLTIuMS4xOS5qcyc6J2xldCBmcnVpdHMgPSBbXCJNYW5nb1wiLCBcIk9yYW5nZVwiLCBcIkFwcGxlXCIsIDMuMCwgXCJCYW5hbmFcIl07XFxyXFxuXFxyXFxuLy8gQXBwbHkgb2ZUeXBlKCkgdG8gdGhlIEFycmF5XFxyXFxubGV0IHF1ZXJ5MSA9IGZydWl0cy5hc0VudW1lcmFibGUoKS5vZlR5cGUoU3RyaW5nKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhcIkVsZW1lbnRzIG9mIHR5cGUgXFwnU3RyaW5nXFwnIGFyZTpcIik7XFxyXFxuZm9yIChsZXQgZnJ1aXQgb2YgcXVlcnkxKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGZydWl0KTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gVGhlIGZvbGxvd2luZyBxdWVyeSBzaG93cyB0aGF0IHRoZSBzdGFuZGFyZCBxdWVyeSBvcGVyYXRvcnMgc3VjaCBhc1xcclxcbi8vIHdoZXJlKCkgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIEFycmF5IHR5cGUgYWZ0ZXIgY2FsbGluZyBvZlR5cGUoKS5cXHJcXG5sZXQgcXVlcnkyID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLm9mVHlwZShTdHJpbmcpLndoZXJlKGZydWl0ID0+IGZydWl0LmFzRW51bWVyYWJsZSgpLmNvbnRhaW5zKFwiblwiLCBFbnVtZXJhYmxlLmNvbXBhcmVycy5pZ25vcmVDYXNlKCkpKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhcIlxcXFxuVGhlIGZvbGxvd2luZyBzdHJpbmdzIGNvbnRhaW4gXFwnblxcJzpcIik7XFxyXFxuZm9yIChsZXQgZnJ1aXQgb2YgcXVlcnkyKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGZydWl0KTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gRWxlbWVudHMgb2YgdHlwZSBcXCdzdHJpbmdcXCcgYXJlOlxcclxcbi8vIE1hbmdvXFxyXFxuLy8gT3JhbmdlXFxyXFxuLy8gQXBwbGVcXHJcXG4vLyBCYW5hbmFcXHJcXG4vL1xcclxcbi8vIFRoZSBmb2xsb3dpbmcgc3RyaW5ncyBjb250YWluIFxcJ25cXCc6XFxyXFxuLy8gTWFuZ29cXHJcXG4vLyBPcmFuZ2VcXHJcXG4vLyBCYW5hbmEnLCcxLmpzJzonbGV0IGZydWl0cyA9IFtcIk1hbmdvXCIsIFwiT3JhbmdlXCIsIFwiQXBwbGVcIiwgMy4wLCBcIkJhbmFuYVwiXTtcXHJcXG5cXHJcXG4vLyBBcHBseSBvZlR5cGUoKSB0byB0aGUgQXJyYXlcXHJcXG5sZXQgcXVlcnkxID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLm9mVHlwZShTdHJpbmcpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKFwiRWxlbWVudHMgb2YgdHlwZSBcXCdTdHJpbmdcXCcgYXJlOlwiKTtcXHJcXG5mb3IgKGxldCBmcnVpdCBvZiBxdWVyeTEpIHtcXHJcXG4gICAgY29uc29sZS5sb2coZnJ1aXQpO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBUaGUgZm9sbG93aW5nIHF1ZXJ5IHNob3dzIHRoYXQgdGhlIHN0YW5kYXJkIHF1ZXJ5IG9wZXJhdG9ycyBzdWNoIGFzXFxyXFxuLy8gd2hlcmUoKSBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXJyYXkgdHlwZSBhZnRlciBjYWxsaW5nIG9mVHlwZSgpLlxcclxcbmxldCBxdWVyeTIgPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkub2ZUeXBlKFN0cmluZykud2hlcmUoZnJ1aXQgPT4gZnJ1aXQudG9Mb3dlckNhc2UoKS5hc0VudW1lcmFibGUoKS5jb250YWlucyhcIm5cIikpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKFwiXFxcXG5UaGUgZm9sbG93aW5nIHN0cmluZ3MgY29udGFpbiBcXCduXFwnOlwiKTtcXHJcXG5mb3IgKGxldCBmcnVpdCBvZiBxdWVyeTIpIHtcXHJcXG4gICAgY29uc29sZS5sb2coZnJ1aXQpO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyBFbGVtZW50cyBvZiB0eXBlIFxcJ3N0cmluZ1xcJyBhcmU6XFxyXFxuLy8gTWFuZ29cXHJcXG4vLyBPcmFuZ2VcXHJcXG4vLyBBcHBsZVxcclxcbi8vIEJhbmFuYVxcclxcbi8vXFxyXFxuLy8gVGhlIGZvbGxvd2luZyBzdHJpbmdzIGNvbnRhaW4gXFwnblxcJzpcXHJcXG4vLyBNYW5nb1xcclxcbi8vIE9yYW5nZVxcclxcbi8vIEJhbmFuYSd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgcGV0cyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBhZ2U6IDggfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIGFnZTogNCB9LFxcclxcbiAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgYWdlOiAxIH1cXHJcXG5dO1xcclxcblxcclxcbmxldCBxdWVyeSA9IHBldHMuYXNFbnVtZXJhYmxlKCkub3JkZXJCeShwZXQgPT4gcGV0LmFnZSk7XFxyXFxuXFxyXFxuZm9yIChsZXQgcGV0IG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGAkeyBwZXQubmFtZSB9IC0gJHsgcGV0LmFnZSB9YCk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gV2hpc2tlcnMgLSAxXFxyXFxuIEJvb3RzIC0gNFxcclxcbiBCYXJsZXkgLSA4XFxyXFxuKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonY29uc3Qgc3BlY2lhbENvbXBhcmVyID0gKGQxLCBkMikgPT4ge1xcclxcbiAgICBsZXQgZjEgPSBkMSAqIDFlMTYgJSAxZTE2IC8gMWUxNjtcXHJcXG4gICAgbGV0IGYyID0gZDIgKiAxZTE2ICUgMWUxNiAvIDFlMTY7XFxyXFxuICAgIGlmIChmMSA9PT0gZjIpIHtcXHJcXG4gICAgICAgIHJldHVybiBkMSAtIGQyO1xcclxcbiAgICB9IGVsc2UgaWYgKGYxID4gZjIpIHtcXHJcXG4gICAgICAgIHJldHVybiAxO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIC0xO1xcclxcbiAgICB9XFxyXFxufTtcXHJcXG5cXHJcXG5sZXQgZGVjaW1hbHMgPSBbIDYuMiwgOC4zLCAwLjUsIDEuMywgNi4zLCA5LjcgXTtcXHJcXG5cXHJcXG5sZXQgcXVlcnkgPSBkZWNpbWFscy5hc0VudW1lcmFibGUoKS5vcmRlckJ5RGVzY2VuZGluZyhudW0gPT4gbnVtLCBzcGVjaWFsQ29tcGFyZXIpO1xcclxcblxcclxcbmZvciAobGV0IG51bSBvZiBxdWVyeSkge1xcclxcbiAgICBjb25zb2xlLmxvZyhudW0pO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIDkuN1xcclxcbiAwLjVcXHJcXG4gOC4zXFxyXFxuIDYuM1xcclxcbiAxLjNcXHJcXG4gNi4yXFxyXFxuKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IHNxdWFyZXMgPSBFbnVtZXJhYmxlLnJhbmdlKDEsIDEwKS5zZWxlY3QoeCA9PiB4ICogeCk7XFxyXFxuXFxyXFxuZm9yIChsZXQgbnVtIG9mIHNxdWFyZXMpIHtcXHJcXG4gICAgY29uc29sZS5sb2cobnVtKTtcXHJcXG59XFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiAxXFxyXFxuIDRcXHJcXG4gOVxcclxcbiAxNlxcclxcbiAyNVxcclxcbiAzNlxcclxcbiA0OVxcclxcbiA2NFxcclxcbiA4MVxcclxcbiAxMDBcXHJcXG4qLycsJzIuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJncmFwZVwiIF07XFxyXFxuXFxyXFxubGV0IHF1ZXJ5ID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLnNlbGVjdCgoZnJ1aXQsIGluZGV4KSA9PiAoeyBpbmRleCwgc3RyOiBmcnVpdC5zdWJzdHJpbmcoMCwgaW5kZXgpIH0pKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBvYmogb2YgcXVlcnkpIHtcXHJcXG4gICAgY29uc29sZS5sb2cob2JqKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiB7XCJpbmRleFwiOjAsXCJzdHJcIjpcIlwifVxcclxcbiB7XCJpbmRleFwiOjEsXCJzdHJcIjpcImJcIn1cXHJcXG4ge1wiaW5kZXhcIjoyLFwic3RyXCI6XCJtYVwifVxcclxcbiB7XCJpbmRleFwiOjMsXCJzdHJcIjpcIm9yYVwifVxcclxcbiB7XCJpbmRleFwiOjQsXCJzdHJcIjpcInBhc3NcIn1cXHJcXG4ge1wiaW5kZXhcIjo1LFwic3RyXCI6XCJncmFwZVwifVxcclxcbiovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBwZXRPd25lcnMgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJIaWdhLCBTaWRuZXlcIiwgcGV0czogWyBcIlNjcnVmZnlcIiwgXCJTYW1cIiBdIH0sXFxyXFxuICAgIHsgbmFtZTogXCJBc2hrZW5hemksIFJvbmVuXCIsIHBldHM6IFsgXCJXYWxrZXJcIiwgXCJTdWdhclwiIF0gfSxcXHJcXG4gICAgeyBuYW1lOiBcIlByaWNlLCBWZXJuZXR0ZVwiLCBwZXRzOiBbIFwiU2NyYXRjaGVzXCIsIFwiRGllc2VsXCIgXSB9XFxyXFxuXTtcXHJcXG5cXHJcXG4vLyBRdWVyeSB1c2luZyBzZWxlY3RNYW55KCkuXFxyXFxubGV0IHF1ZXJ5MSA9IHBldE93bmVycy5hc0VudW1lcmFibGUoKS5zZWxlY3RNYW55KHBldE93bmVyID0+IHBldE93bmVyLnBldHMpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKFwiVXNpbmcgc2VsZWN0TWFueSgpOlwiKTtcXHJcXG5cXHJcXG4vLyBPbmx5IG9uZSBmb3JlYWNoIGxvb3AgaXMgcmVxdWlyZWQgdG8gaXRlcmF0ZVxcclxcbi8vIHRocm91Z2ggdGhlIHJlc3VsdHMgc2luY2UgaXQgaXMgYVxcclxcbi8vIG9uZS1kaW1lbnNpb25hbCBjb2xsZWN0aW9uLlxcclxcbmZvciAobGV0IHBldCBvZiBxdWVyeTEpIHtcXHJcXG4gICAgY29uc29sZS5sb2cocGV0KTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHNob3dzIGhvdyB0byB1c2Ugc2VsZWN0KClcXHJcXG4vLyBpbnN0ZWFkIG9mIHNlbGVjdE1hbnkoKS5cXHJcXG5sZXQgcXVlcnkyID0gcGV0T3duZXJzLmFzRW51bWVyYWJsZSgpLnNlbGVjdChwZXRPd25lciA9PiBwZXRPd25lci5wZXRzKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhcIlxcXFxuVXNpbmcgc2VsZWN0KCk6XCIpO1xcclxcblxcclxcbi8vIE5vdGljZSB0aGF0IHR3byBmb3JlYWNoIGxvb3BzIGFyZSByZXF1aXJlZCB0b1xcclxcbi8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgcmVzdWx0c1xcclxcbi8vIGJlY2F1c2UgdGhlIHF1ZXJ5IHJldHVybnMgYSBjb2xsZWN0aW9uIG9mIGFycmF5cy5cXHJcXG5mb3IgKGxldCBwZXRMaXN0IG9mIHF1ZXJ5Mikge1xcclxcbiAgICBmb3IgKGxldCBwZXQgb2YgcGV0TGlzdCkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2cocGV0KTtcXHJcXG4gICAgfVxcclxcbiAgICBjb25zb2xlLmxvZygpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFVzaW5nIHNlbGVjdE1hbnkoKTpcXHJcXG4gU2NydWZmeVxcclxcbiBTYW1cXHJcXG4gV2Fsa2VyXFxyXFxuIFN1Z2FyXFxyXFxuIFNjcmF0Y2hlc1xcclxcbiBEaWVzZWxcXHJcXG5cXHJcXG4gVXNpbmcgc2VsZWN0KCk6XFxyXFxuIFNjcnVmZnlcXHJcXG4gU2FtXFxyXFxuXFxyXFxuIFdhbGtlclxcclxcbiBTdWdhclxcclxcblxcclxcbiBTY3JhdGNoZXNcXHJcXG4gRGllc2VsXFxyXFxuXFxyXFxuKi8nLCcyLmpzJzonbGV0IHBldE93bmVycyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkhpZ2EsIFNpZG5leVwiLCBwZXRzOiBbIFwiU2NydWZmeVwiLCBcIlNhbVwiIF0gfSxcXHJcXG4gICAgeyBuYW1lOiBcIkFzaGtlbmF6aSwgUm9uZW5cIiwgcGV0czogWyBcIldhbGtlclwiLCBcIlN1Z2FyXCIgXSB9LFxcclxcbiAgICB7IG5hbWU6IFwiUHJpY2UsIFZlcm5ldHRlXCIsIHBldHM6IFsgXCJTY3JhdGNoZXNcIiwgXCJEaWVzZWxcIiBdIH0sXFxyXFxuICAgIHsgbmFtZTogXCJIaW5lcywgUGF0cmlja1wiLCBwZXRzOiBbIFwiRHVzdHlcIiBdIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIFByb2plY3QgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBieSBhcHBlbmRpbmcgdGhlIGluZGV4XFxyXFxuLy8gb2YgZWFjaCBQZXRPd25lciB0byBlYWNoIHBldFxcJ3MgbmFtZSBpbiB0aGF0IHBldE93bmVyXFwnc1xcclxcbi8vIGFycmF5IG9mIHBldHMuXFxyXFxubGV0IHF1ZXJ5ID0gcGV0T3duZXJzLmFzRW51bWVyYWJsZSgpLnNlbGVjdE1hbnkoKHBldE93bmVyLCBpbmRleCkgPT5cXHJcXG4gICAgICAgIHBldE93bmVyLnBldHMuYXNFbnVtZXJhYmxlKCkuc2VsZWN0KHBldCA9PiBpbmRleCArIHBldCkpO1xcclxcblxcclxcbmZvciAobGV0IHBldCBvZiBxdWVyeSkge1xcclxcbiAgICBjb25zb2xlLmxvZyhwZXQpO1xcclxcbn1cXHJcXG5cXHJcXG4vLyBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuLy9cXHJcXG4vLyAwU2NydWZmeVxcclxcbi8vIDBTYW1cXHJcXG4vLyAxV2Fsa2VyXFxyXFxuLy8gMVN1Z2FyXFxyXFxuLy8gMlNjcmF0Y2hlc1xcclxcbi8vIDJEaWVzZWxcXHJcXG4vLyAzRHVzdHknLCczLmpzJzonbGV0IHBldE93bmVycyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkhpZ2EsIFNpZG5leVwiLCBwZXRzOiBbIFwiU2NydWZmeVwiLCBcIlNhbVwiIF0gfSxcXHJcXG4gICAgeyBuYW1lOiBcIkFzaGtlbmF6aSwgUm9uZW5cIiwgcGV0czogWyBcIldhbGtlclwiLCBcIlN1Z2FyXCIgXSB9LFxcclxcbiAgICB7IG5hbWU6IFwiUHJpY2UsIFZlcm5ldHRlXCIsIHBldHM6IFsgXCJTY3JhdGNoZXNcIiwgXCJEaWVzZWxcIiBdIH0sXFxyXFxuICAgIHsgbmFtZTogXCJIaW5lcywgUGF0cmlja1wiLCBwZXRzOiBbIFwiRHVzdHlcIiBdIH1cXHJcXG5dO1xcclxcblxcclxcbi8vIFByb2plY3QgdGhlIHBldCBvd25lclxcJ3MgbmFtZSBhbmQgdGhlIHBldFxcJ3MgbmFtZS5cXHJcXG5sZXQgcXVlcnkgPSBwZXRPd25lcnMuYXNFbnVtZXJhYmxlKCkuc2VsZWN0TWFueShwZXRPd25lciA9PiBwZXRPd25lci5wZXRzLCAocGV0T3duZXIsIHBldE5hbWUpID0+ICh7IHBldE93bmVyLCBwZXROYW1lIH0pKVxcclxcbiAgICAgICAgLndoZXJlKG93bmVyQW5kUGV0ID0+IG93bmVyQW5kUGV0LnBldE5hbWUuc3RhcnRzV2l0aChcIlNcIikpXFxyXFxuICAgICAgICAuc2VsZWN0KG93bmVyQW5kUGV0ID0+ICh7XFxyXFxuICAgICAgICAgICAgb3duZXI6IG93bmVyQW5kUGV0LnBldE93bmVyLm5hbWUsXFxyXFxuICAgICAgICAgICAgcGV0OiBvd25lckFuZFBldC5wZXROYW1lXFxyXFxuICAgICAgICB9KSk7XFxyXFxuXFxyXFxuLy8gUHJpbnQgdGhlIHJlc3VsdHMuXFxyXFxuZm9yIChsZXQgb2JqIG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKG9iaik7XFxyXFxufVxcclxcblxcclxcbi8vIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG4vL1xcclxcbi8vIHtcIm93bmVyXCI6XCJIaWdhXCIsXCJwZXRcIjpcIlNjcnVmZnlcIn1cXHJcXG4vLyB7XCJvd25lclwiOlwiSGlnYVwiLFwicGV0XCI6XCJTYW1cIn1cXHJcXG4vLyB7XCJvd25lclwiOlwiQXNoa2VuYXppXCIsXCJwZXRcIjpcIlN1Z2FyXCJ9XFxyXFxuLy8ge1wib3duZXJcIjpcIlByaWNlXCIsXCJwZXRcIjpcIlNjcmF0Y2hlc1wifSd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgcGV0MSA9IHsgbmFtZTogXCJUdXJib1wiLCBhZ2U6IDIgfTtcXHJcXG5sZXQgcGV0MiA9IHsgbmFtZTogXCJQZWFudXRcIiwgYWdlOiA4IH07XFxyXFxuXFxyXFxuLy8gQ3JlYXRlIHR3byBsaXN0cyBvZiBwZXRzLlxcclxcbmxldCBwZXRzMSA9IFsgcGV0MSwgcGV0MiBdO1xcclxcbmxldCBwZXRzMiA9IFsgcGV0MSwgcGV0MiBdO1xcclxcblxcclxcbmxldCBlcXVhbCA9IHBldHMxLmFzRW51bWVyYWJsZSgpLnNlcXVlbmNlRXF1YWwocGV0czIpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGBUaGUgbGlzdHMgJHsgZXF1YWwgPyBcImFyZVwiIDogXCJhcmUgbm90XCIgfSBlcXVhbC5gKTtcXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFRoZSBsaXN0cyBhcmUgZXF1YWwuXFxyXFxuKi8nLCcyLmpzJzonLy8g5LiA5Liq6Ieq5a6a5LmJ55qE5q+U6L6D5Zmo44CCXFxyXFxubGV0IHByb2R1Y3RDb21wYXJlciA9ICh4LCB5KSA9PiB7XFxyXFxuICAgIGlmICh4ID09PSB5KSByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgaWYgKCF4IHx8ICF5KSByZXR1cm4gZmFsc2U7XFxyXFxuICAgIC8vIOWmguaenOS6p+WTgeeahOWQjeensOWSjOaVsOebruebuOetie+8jOWImeihqOekuuaYr+ebuOWQjOeahOS6p+WTgeOAglxcclxcbiAgICByZXR1cm4geC5jb2RlID09PSB5LmNvZGUgJiYgeC5uYW1lID09PSB5Lm5hbWU7XFxyXFxufTtcXHJcXG5cXHJcXG5sZXQgc3RvcmVBID0gW1xcclxcbiAgICB7IG5hbWU6IFwiYXBwbGVcIiwgY29kZTogOSB9LFxcclxcbiAgICB7IG5hbWU6IFwib3JhbmdlXCIsIGNvZGU6IDQgfVxcclxcbl07XFxyXFxuXFxyXFxubGV0IHN0b3JlQiA9IFtcXHJcXG4gICAgeyBuYW1lOiBcImFwcGxlXCIsIGNvZGU6IDkgfSxcXHJcXG4gICAgeyBuYW1lOiBcIm9yYW5nZVwiLCBjb2RlOiA0IH1cXHJcXG5dO1xcclxcblxcclxcbmxldCBlcXVhbEFCID0gc3RvcmVBLmFzRW51bWVyYWJsZSgpLnNlcXVlbmNlRXF1YWwoc3RvcmVCLCBwcm9kdWN0Q29tcGFyZXIpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKFwiRXF1YWw/IFwiICsgZXF1YWxBQik7XFxyXFxuXFxyXFxuLypcXHJcXG4gICAgVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiAgICBFcXVhbD8gVHJ1ZVxcclxcbiovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBmcnVpdHMxID0gWyBcIm9yYW5nZVwiIF07XFxyXFxuXFxyXFxubGV0IGZydWl0MSA9IGZydWl0czEuYXNFbnVtZXJhYmxlKCkuc2luZ2xlKCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coZnJ1aXQxKTtcXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIG9yYW5nZVxcclxcbiovJywnMi5qcyc6J2xldCBmcnVpdHMyID0gWyBcIm9yYW5nZVwiLCBcImFwcGxlXCIgXTtcXHJcXG5sZXQgZnJ1aXQyID0gbnVsbDtcXHJcXG5cXHJcXG50cnkge1xcclxcbiAgICBmcnVpdDIgPSBmcnVpdHMyLmFzRW51bWVyYWJsZSgpLnNpbmdsZSgpO1xcclxcbiAgICBjb25zb2xlLmxvZyhmcnVpdDIpO1xcclxcbn0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgY29uc29sZS5sb2coXCJUaGUgY29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIGV4YWN0bHkgb25lIGVsZW1lbnQuXCIpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gZXhhY3RseSBvbmUgZWxlbWVudC5cXHJcXG4qL1xcclxcbicsJzMuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJncmFwZVwiIF07XFxyXFxuXFxyXFxubGV0IGZydWl0MSA9IGZydWl0cy5hc0VudW1lcmFibGUoKS5zaW5nbGUoZnJ1aXQgPT4gZnJ1aXQubGVuZ3RoID4gMTApO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGZydWl0MSk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBwYXNzaW9uZnJ1aXRcXHJcXG4qLycsJzQuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJncmFwZVwiIF07XFxyXFxubGV0IGZydWl0MiA9IG51bGw7XFxyXFxuXFxyXFxudHJ5IHtcXHJcXG4gICAgZnJ1aXQyID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLnNpbmdsZShmcnVpdCA9PiBmcnVpdC5sZW5ndGggPiAxNSk7XFxyXFxuXFxyXFxuICAgIGNvbnNvbGUubG9nKGZydWl0Mik7XFxyXFxufSBjYXRjaCAoZSkge1xcclxcbiAgICBjb25zb2xlLmxvZyhcIlRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gZXhhY3RseSBvbmUgZWxlbWVudCB3aG9zZSBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIDE1LlwiKTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gVGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBleGFjdGx5IG9uZSBlbGVtZW50IHdob3NlIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMTUuJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBmcnVpdHMxID0gWyBcIm9yYW5nZVwiIF07XFxyXFxuXFxyXFxubGV0IGZydWl0MSA9IGZydWl0czEuYXNFbnVtZXJhYmxlKCkuc2luZ2xlT3JEZWZhdWx0KFwiTm8gc3VjaCBzdHJpbmchXCIpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKGZydWl0MSk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBvcmFuZ2VcXHJcXG4qLycsJzIuanMnOidsZXQgZnJ1aXRzMiA9IFtdO1xcclxcblxcclxcbmxldCBmcnVpdDIgPSBmcnVpdHMyLmFzRW51bWVyYWJsZSgpLnNpbmdsZU9yRGVmYXVsdChcIk5vIHN1Y2ggc3RyaW5nIVwiKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhmcnVpdDIpO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gTm8gc3VjaCBzdHJpbmchXFxyXFxuKi8nLCczLmpzJzonbGV0IGZydWl0cyA9IFsgXCJhcHBsZVwiLCBcImJhbmFuYVwiLCBcIm1hbmdvXCIsIFwib3JhbmdlXCIsIFwicGFzc2lvbmZydWl0XCIsIFwiZ3JhcGVcIiBdO1xcclxcblxcclxcbmxldCBmcnVpdDEgPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkuc2luZ2xlT3JEZWZhdWx0KFwiTm8gc3VjaCBzdHJpbmchXCIsIGZydWl0ID0+IGZydWl0Lmxlbmd0aCA+IDEwKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhmcnVpdDEpO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gcGFzc2lvbmZydWl0XFxyXFxuKi8nLCc0LmpzJzonbGV0IGZydWl0cyA9IFsgXCJhcHBsZVwiLCBcImJhbmFuYVwiLCBcIm1hbmdvXCIsIFwib3JhbmdlXCIsIFwicGFzc2lvbmZydWl0XCIsIFwiZ3JhcGVcIiBdO1xcclxcblxcclxcbmxldCBmcnVpdDIgPSBmcnVpdHMuYXNFbnVtZXJhYmxlKCkuc2luZ2xlT3JEZWZhdWx0KFwiTm8gc3VjaCBzdHJpbmchXCIsIGZydWl0ID0+IGZydWl0Lmxlbmd0aCA+IDE1KTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhmcnVpdDIpO1xcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gTm8gc3VjaCBzdHJpbmchXFxyXFxuKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IGdyYWRlcyA9IFsgNTksIDgyLCA3MCwgNTYsIDkyLCA5OCwgODUgXTtcXHJcXG5cXHJcXG5sZXQgbG93ZXJHcmFkZXMgPSBncmFkZXMuYXNFbnVtZXJhYmxlKCkub3JkZXJCeURlc2NlbmRpbmcoZyA9PiBnKS5za2lwKDMpO1xcclxcblxcclxcbmNvbnNvbGUubG9nKFwiQWxsIGdyYWRlcyBleGNlcHQgdGhlIHRvcCB0aHJlZSBhcmU6XCIpO1xcclxcbmZvciAobGV0IGdyYWRlIG9mIGxvd2VyR3JhZGVzKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGdyYWRlKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBBbGwgZ3JhZGVzIGV4Y2VwdCB0aGUgdG9wIHRocmVlIGFyZTpcXHJcXG4gODJcXHJcXG4gNzBcXHJcXG4gNTlcXHJcXG4gNTZcXHJcXG4qLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgZ3JhZGVzID0gWyA1OSwgODIsIDcwLCA1NiwgOTIsIDk4LCA4NSBdO1xcclxcblxcclxcbmxldCBsb3dlckdyYWRlcyA9IGdyYWRlcy5hc0VudW1lcmFibGUoKS5vcmRlckJ5RGVzY2VuZGluZygpLnNraXBXaGlsZShncmFkZSA9PiBncmFkZSA+PSA4MCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coXCJBbGwgZ3JhZGVzIGJlbG93IDgwOlwiKTtcXHJcXG5mb3IgKGxldCBncmFkZSBvZiBsb3dlckdyYWRlcykge1xcclxcbiAgICBjb25zb2xlLmxvZyhncmFkZSk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gQWxsIGdyYWRlcyBiZWxvdyA4MDpcXHJcXG4gNzBcXHJcXG4gNTlcXHJcXG4gNTZcXHJcXG4qLycsJzIuanMnOidsZXQgYW1vdW50cyA9IFsgNTAwMCwgMjUwMCwgOTAwMCwgODAwMCwgNjUwMCwgNDAwMCwgMTUwMCwgNTUwMCBdO1xcclxcblxcclxcbmxldCBxdWVyeSA9IGFtb3VudHMuYXNFbnVtZXJhYmxlKCkuc2tpcFdoaWxlKChhbW91bnQsIGluZGV4KSA9PiBhbW91bnQgPiBpbmRleCAqIDEwMDApO1xcclxcblxcclxcbmZvciAobGV0IGFtb3VudCBvZiBxdWVyeSkge1xcclxcbiAgICBjb25zb2xlLmxvZyhhbW91bnQpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIDQwMDBcXHJcXG4gMTUwMFxcclxcbiA1NTAwXFxyXFxuKi8nfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IG51bWJlcnMgPSBbIDQzLjY4LCAxLjI1LCA1ODMuNywgNi41IF07XFxyXFxuXFxyXFxubGV0IHN1bSA9IG51bWJlcnMuYXNFbnVtZXJhYmxlKCkuc3VtKCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSBzdW0gb2YgdGhlIG51bWJlcnMgaXMgJHsgc3VtIH0uYCk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBUaGUgc3VtIG9mIHRoZSBudW1iZXJzIGlzIDYzNS4xMy5cXHJcXG4qLycsJzIuanMnOidsZXQgcGFja2FnZXMgPSBbXFxyXFxuICAgIHsgY29tcGFueTogXCJDb2hvIFZpbmV5YXJkXCIsIHdlaWdodDogMjUuMiB9LFxcclxcbiAgICB7IGNvbXBhbnk6IFwiTHVjZXJuZSBQdWJsaXNoaW5nXCIsIHdlaWdodDogMTguNyB9LFxcclxcbiAgICB7IGNvbXBhbnk6IFwiV2luZ3RpcCBUb3lzXCIsIHdlaWdodDogNi4wIH0sXFxyXFxuICAgIHsgY29tcGFueTogXCJBZHZlbnR1cmUgV29ya3NcIiwgd2VpZ2h0OiAzMy45IH1cXHJcXG5dO1xcclxcblxcclxcbmxldCB0b3RhbFdlaWdodCA9IHBhY2thZ2VzLmFzRW51bWVyYWJsZSgpLnN1bShwa2cgPT4gcGtnLndlaWdodCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZSB0b3RhbCB3ZWlnaHQgb2YgdGhlIHBhY2thZ2VzIGlzOiAkeyB0b3RhbFdlaWdodCB9YCk7XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBUaGUgdG90YWwgd2VpZ2h0IG9mIHRoZSBwYWNrYWdlcyBpczogODMuOFxcclxcbiovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBncmFkZXMgPSBbIDU5LCA4MiwgNzAsIDU2LCA5MiwgOTgsIDg1IF07XFxyXFxuXFxyXFxubGV0IHRvcFRocmVlR3JhZGVzID0gZ3JhZGVzLmFzRW51bWVyYWJsZSgpLm9yZGVyQnlEZXNjZW5kaW5nKCkudGFrZSgzKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhcIlRoZSB0b3AgdGhyZWUgZ3JhZGVzIGFyZTpcIik7XFxyXFxuZm9yIChsZXQgZ3JhZGUgb2YgdG9wVGhyZWVHcmFkZXMpIHtcXHJcXG4gICAgY29uc29sZS5sb2coZ3JhZGUpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIFRoZSB0b3AgdGhyZWUgZ3JhZGVzIGFyZTpcXHJcXG4gOThcXHJcXG4gOTJcXHJcXG4gODVcXHJcXG4qLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJncmFwZVwiIF07XFxyXFxuXFxyXFxubGV0IHF1ZXJ5ID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLnRha2VXaGlsZShmcnVpdCA9PiBcIm9yYW5nZVwiICE9PSBmcnVpdCk7XFxyXFxuXFxyXFxuZm9yIChsZXQgZnJ1aXQgb2YgcXVlcnkpIHtcXHJcXG4gICAgY29uc29sZS5sb2coZnJ1aXQpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuIGFwcGxlXFxyXFxuIGJhbmFuYVxcclxcbiBtYW5nb1xcclxcbiovJywnMi5qcyc6J2xldCBmcnVpdHMgPSBbIFwiYXBwbGVcIiwgXCJwYXNzaW9uZnJ1aXRcIiwgXCJiYW5hbmFcIiwgXCJtYW5nb1wiLCBcIm9yYW5nZVwiLCBcImJsdWViZXJyeVwiLCBcImdyYXBlXCIsIFwic3RyYXdiZXJyeVwiIF07XFxyXFxuXFxyXFxubGV0IHF1ZXJ5ID0gZnJ1aXRzLmFzRW51bWVyYWJsZSgpLnRha2VXaGlsZSgoZnJ1aXQsIGluZGV4KSA9PiBmcnVpdC5sZW5ndGggPj0gaW5kZXgpO1xcclxcblxcclxcbmZvciAobGV0IGZydWl0IG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGZydWl0KTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBhcHBsZVxcclxcbiBwYXNzaW9uZnJ1aXRcXHJcXG4gYmFuYW5hXFxyXFxuIG1hbmdvXFxyXFxuIG9yYW5nZVxcclxcbiBibHVlYmVycnlcXHJcXG4qLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgaW50czEgPSBbIDUsIDMsIDksIDcsIDUsIDksIDMsIDcgXTtcXHJcXG5sZXQgaW50czIgPSBbIDgsIDMsIDYsIDQsIDQsIDksIDEsIDAgXTtcXHJcXG5cXHJcXG5sZXQgdW5pb24gPSBpbnRzMS5hc0VudW1lcmFibGUoKS51bmlvbihpbnRzMik7XFxyXFxuXFxyXFxuZm9yIChsZXQgbnVtIG9mIHVuaW9uKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKG51bSk7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gNVxcclxcbiAzXFxyXFxuIDlcXHJcXG4gN1xcclxcbiA4XFxyXFxuIDZcXHJcXG4gNFxcclxcbiAxXFxyXFxuIDBcXHJcXG4qLycsJzIuanMnOicvLyDkuIDkuKroh6rlrprkuYnnmoTmr5TovoPlmajjgIJcXHJcXG5sZXQgcHJvZHVjdENvbXBhcmVyID0gKHgsIHkpID0+IHtcXHJcXG4gICAgaWYgKHggPT09IHkpIHJldHVybiB0cnVlO1xcclxcbiAgICBpZiAoIXggfHwgIXkpIHJldHVybiBmYWxzZTtcXHJcXG4gICAgLy8g5aaC5p6c5Lqn5ZOB55qE5ZCN56ew5ZKM57yW5Y+355u4562J77yM5YiZ6KGo56S65piv55u45ZCM55qE5Lqn5ZOB44CCXFxyXFxuICAgIHJldHVybiB4LmNvZGUgPT09IHkuY29kZSAmJiB4Lm5hbWUgPT09IHkubmFtZTtcXHJcXG59O1xcclxcblxcclxcbmxldCBzdG9yZTEgPSBbXFxyXFxuICAgIHsgbmFtZTogXCJhcHBsZVwiLCBjb2RlOiA5IH0sXFxyXFxuICAgIHsgbmFtZTogXCJvcmFuZ2VcIiwgY29kZTogNCB9XFxyXFxuXTtcXHJcXG5cXHJcXG5sZXQgc3RvcmUyID0gW1xcclxcbiAgICB7IG5hbWU6IFwiYXBwbGVcIiwgY29kZTogOSB9LFxcclxcbiAgICB7IG5hbWU6IFwibGVtb25cIiwgY29kZTogMTIgfVxcclxcbl07XFxyXFxuXFxyXFxuLy9HZXQgdGhlIHByb2R1Y3RzIGZyb20gdGhlIGJvdGggYXJyYXlzXFxyXFxuLy9leGNsdWRpbmcgZHVwbGljYXRlcy5cXHJcXG5sZXQgdW5pb24gPSBzdG9yZTEuYXNFbnVtZXJhYmxlKCkudW5pb24oc3RvcmUyLCBwcm9kdWN0Q29tcGFyZXIpO1xcclxcblxcclxcbmZvciAobGV0IHByb2R1Y3Qgb2YgdW5pb24pIHtcXHJcXG4gICAgY29uc29sZS5sb2cocHJvZHVjdC5uYW1lICsgXCIgXCIgKyBwcm9kdWN0LmNvZGUpO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbiAgICBUaGlzIGNvZGUgcHJvZHVjZXMgdGhlIGZvbGxvd2luZyBvdXRwdXQ6XFxyXFxuXFxyXFxuICAgIGFwcGxlIDlcXHJcXG4gICAgb3JhbmdlIDRcXHJcXG4gICAgbGVtb24gMTJcXHJcXG4qLyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgZnJ1aXRzID0gWyBcImFwcGxlXCIsIFwicGFzc2lvbmZydWl0XCIsIFwiYmFuYW5hXCIsIFwibWFuZ29cIiwgXCJvcmFuZ2VcIiwgXCJibHVlYmVycnlcIiwgXCJncmFwZVwiLCBcInN0cmF3YmVycnlcIiBdO1xcclxcblxcclxcbmxldCBxdWVyeSA9IGZydWl0cy5hc0VudW1lcmFibGUoKS53aGVyZShmcnVpdCA9PiBmcnVpdC5sZW5ndGggPCA2KTtcXHJcXG5cXHJcXG5mb3IgKGxldCBmcnVpdCBvZiBxdWVyeSkge1xcclxcbiAgICBjb25zb2xlLmxvZyhmcnVpdCk7XFxyXFxufVxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gYXBwbGVcXHJcXG4gbWFuZ29cXHJcXG4gZ3JhcGVcXHJcXG4qLycsJzIuanMnOidsZXQgbnVtYmVycyA9IFsgMCwgMzAsIDIwLCAxNSwgOTAsIDg1LCA0MCwgNzUgXTtcXHJcXG5cXHJcXG5sZXQgcXVlcnkgPSBudW1iZXJzLmFzRW51bWVyYWJsZSgpLndoZXJlKChudW1iZXIsIGluZGV4KSA9PiBudW1iZXIgPD0gaW5kZXggKiAxMCk7XFxyXFxuXFxyXFxuZm9yIChsZXQgbnVtYmVyIG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKG51bWJlcik7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuIFRoaXMgY29kZSBwcm9kdWNlcyB0aGUgZm9sbG93aW5nIG91dHB1dDpcXHJcXG5cXHJcXG4gMFxcclxcbiAyMFxcclxcbiAxNVxcclxcbiA0MFxcclxcbiovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnMS5qcyc6J2xldCBudW1iZXJzID0gWyAxLCAyLCAzLCA0IF07XFxyXFxubGV0IHdvcmRzID0gWyBcIm9uZVwiLCBcInR3b1wiLCBcInRocmVlXCIgXTtcXHJcXG5cXHJcXG5sZXQgbnVtYmVyc0FuZFdvcmRzID0gbnVtYmVycy5hc0VudW1lcmFibGUoKS56aXAod29yZHMsIChmaXJzdCwgc2Vjb25kKSA9PiBmaXJzdCArIFwiIFwiICsgc2Vjb25kKTtcXHJcXG5cXHJcXG5mb3IgKGxldCBpdGVtIG9mIG51bWJlcnNBbmRXb3Jkcykge1xcclxcbiAgICBjb25zb2xlLmxvZyhpdGVtKTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcblxcclxcbi8vIDEgb25lXFxyXFxuLy8gMiB0d29cXHJcXG4vLyAzIHRocmVlJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHsnY29uZmlnLmFzLmpzJzpcIkVudW1lcmFibGUuY29uZmlnLmFzID0gJ2VtJztcXHJcXG5sZXQgZW51bWVyYWJsZSA9IFsxLCAyLCAzXS5lbSgpO1wiLCdjb25maWcuZXh0ZW5kcy5qcyc6J0VudW1lcmFibGUuY29uZmlnLmV4dGVuZHMuYXJyYXkgPSB0cnVlOyAvL09wZW4gZXh0ZW5kcyBmb3IgQXJyYXkuIEFmdGVyIG9wZW4gdGhpcywgQXJyYXkgd2lsbCBoYXZlIGFsbCB0aGUgZmVhdHVyZXMgb2YgTElOUSBhbmQgeW91IGNhbiB1c2UgbWV0aG9kcyBvZiBMSU5RIGZvciBBcnJheS4gKFN1Z2dlc3QpXFxyXFxuRW51bWVyYWJsZS5jb25maWcuZXh0ZW5kcy5zdHJpbmcgPSB0cnVlOyAvL09wZW4gZXh0ZW5kcyBmb3IgU3RyaW5nLiBBZnRlciBvcGVuIHRoaXMsIFN0cmluZyB3aWxsIGhhdmUgYWxsIHRoZSBmZWF0dXJlcyBvZiBMSU5RIGFuZCB5b3UgY2FuIHVzZSBtZXRob2RzIG9mIExJTlEgZm9yIFN0cmluZy4oTm90IHN1Z2dlc3QpXFxyXFxuRW51bWVyYWJsZS5jb25maWcuZXh0ZW5kcy5vYmplY3QgPSB0cnVlOyAvL09wZW4gZXh0ZW5kcyBmb3IgT2JqZWN0LiBBZnRlciBvcGVuIHRoaXMsIGVhY2ggb2JqZWN0IHdpbGwgaGF2ZSBhbGwgdGhlIGZlYXR1cmVzIG9mIExJTlEgYW5kIHlvdSBjYW4gdXNlIG1ldGhvZHMgb2YgTElOUSBmb3IgZXZlcnkgb2JqZWN0LihOb3Qgc3VnZ2VzdCknfSIsIm1vZHVsZS5leHBvcnRzID0geydhc0VudW1lcmFibGUuanMnOlwibGV0IGEgPSBbMSwgMiwgM10uYXNFbnVtZXJhYmxlKCk7XFxyXFxubGV0IG8gPSAoeyBrZXk6IDEsIHZhbHVlOiAnYScgfSkuYXNFbnVtZXJhYmxlKCk7XFxyXFxubGV0IHMgPSAnYWJjJy5hc0VudW1lcmFibGUoKTtcIiwnRW51bWVyYWJsZS5hc0VudW1lcmFibGUuanMnOidsZXQgZW51bWVyYWJsZSA9IEVudW1lcmFibGUuYXNFbnVtZXJhYmxlKFsxLCAyLCAzXSk7JywnRW51bWVyYWJsZS5qcyc6J2xldCBlbnVtZXJhYmxlID0gRW51bWVyYWJsZShbMSwgMiwgM10pOyd9IiwibW9kdWxlLmV4cG9ydHMgPSB7JzEuanMnOidsZXQgcGV0cyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBwcm9wczogeyBhZ2U6IDEwLCB3ZWlnaHQ6IDU5IH0gfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIHByb3BzOiB7IGFnZTogMTQsIHdlaWdodDogNTAgfSB9LFxcclxcbiAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgcHJvcHM6IHsgYWdlOiA2LCB3ZWlnaHQ6IDM2IH0gfVxcclxcbl07XFxyXFxuXFxyXFxucGV0cy5hc0VudW1lcmFibGUoKS5zZWxlY3QoXCJuYW1lXCIpO1xcclxcbi8vdGhlIGFib3ZlIGNvZGUgYW5kIHRoZSBmb2xsb3dpbmcgY29kZSBhcmUgc2FtZSBmZWF0dXJlLlxcclxcbnBldHMuYXNFbnVtZXJhYmxlKCkuc2VsZWN0KHBldCA9PiBwZXQubmFtZSk7JywnMS50cnkuanMnOidsZXQgcGV0cyA9IFtcXHJcXG4gICAgeyBuYW1lOiBcIkJhcmxleVwiLCBwcm9wczogeyBhZ2U6IDEwLCB3ZWlnaHQ6IDU5IH0gfSxcXHJcXG4gICAgeyBuYW1lOiBcIkJvb3RzXCIsIHByb3BzOiB7IGFnZTogMTQsIHdlaWdodDogNTAgfSB9LFxcclxcbiAgICB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgcHJvcHM6IHsgYWdlOiA2LCB3ZWlnaHQ6IDM2IH0gfVxcclxcbl07XFxyXFxuXFxyXFxuY29uc29sZS5sb2cocGV0cy5hc0VudW1lcmFibGUoKS5zZWxlY3QoXCJuYW1lXCIpKTtcXHJcXG4vL3RoZSBhYm92ZSBjb2RlIGFuZCB0aGUgZm9sbG93aW5nIGNvZGUgYXJlIHNhbWUgZmVhdHVyZS5cXHJcXG5jb25zb2xlLmxvZyhwZXRzLmFzRW51bWVyYWJsZSgpLnNlbGVjdChwZXQgPT4gcGV0Lm5hbWUpKTsnLCcyLmpzJzonbGV0IGFycmF5cyA9IFtcXHJcXG4gICAgWyAxLCAyLCA0LCA4IF0sXFxyXFxuICAgIFsgMSwgMywgOSBdLFxcclxcbiAgICBbIDEsIDUgXVxcclxcbl07XFxyXFxuXFxyXFxuYXJyYXlzLmFzRW51bWVyYWJsZSgpLnNlbGVjdCgxKTtcXHJcXG4vL3RoZSBhYm92ZSBjb2RlIGFuZCB0aGUgZm9sbG93aW5nIGNvZGUgYXJlIHNhbWUgZmVhdHVyZS5cXHJcXG5hcnJheXMuYXNFbnVtZXJhYmxlKCkuc2VsZWN0KGFycmF5ID0+IGFycmF5WzFdKTsnfSIsIm1vZHVsZS5leHBvcnRzID0geycxLmpzJzonbGV0IHBldHMgPSBbIHsgbmFtZTogXCJCYXJsZXlcIiwgYWdlOiA4LCB2YWNjaW5hdGVkOiB0cnVlIH0sIHsgbmFtZTogXCJCb290c1wiLCBhZ2U6IDQsIHZhY2NpbmF0ZWQ6IGZhbHNlIH0sIHsgbmFtZTogXCJXaGlza2Vyc1wiLCBhZ2U6IDEsIHZhY2NpbmF0ZWQ6IGZhbHNlIH0gXTtcXHJcXG5cXHJcXG5sZXQgdW52YWNjaW5hdGVkID0gcGV0cy5hc0VudW1lcmFibGUoKS5hbnkocCA9PiBwLmFnZSA+IDEgJiYgcC52YWNjaW5hdGVkID09PSBmYWxzZSk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coYFRoZXJlICR7IHVudmFjY2luYXRlZCA/IFwiYXJlXCIgOiBcImFyZSBub3QgYW55XCIgfSB1bnZhY2NpbmF0ZWQgYW5pbWFscyBvdmVyIGFnZSBvbmUuYCk7XFxyXFxuXFxyXFxuLy8gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0Olxcclxcbi8vXFxyXFxuLy8gIFRoZXJlIGFyZSB1bnZhY2NpbmF0ZWQgYW5pbWFscyBvdmVyIGFnZSBvbmUuJywnMi5qcyc6J2xldCBtYWdudXMgPSB7IG5hbWU6IFwiSGVkbHVuZCwgTWFnbnVzXCIgfSwgdGVycnkgPSB7IG5hbWU6IFwiQWRhbXMsIFRlcnJ5XCIgfSwgY2hhcmxvdHRlID0geyBuYW1lOiBcIldlaXNzLCBDaGFybG90dGVcIiB9O1xcclxcbmxldCBiYXJsZXkgPSB7IG5hbWU6IFwiQmFybGV5XCIsIG93bmVyOiB0ZXJyeSB9LCBib290cyA9IHsgbmFtZTogXCJCb290c1wiLCBvd25lcjogdGVycnkgfSwgd2hpc2tlcnMgPSB7IG5hbWU6IFwiV2hpc2tlcnNcIiwgb3duZXI6IGNoYXJsb3R0ZSB9LCBkYWlzeSA9IHsgbmFtZTogXCJEYWlzeVwiLCBvd25lcjogbWFnbnVzIH07XFxyXFxubGV0IHBlb3BsZSA9IFsgbWFnbnVzLCB0ZXJyeSwgY2hhcmxvdHRlIF07XFxyXFxubGV0IHBldHMgPSBbIGJhcmxleSwgYm9vdHMsIHdoaXNrZXJzLCBkYWlzeSBdO1xcclxcblxcclxcbmxldCBxdWVyeSA9IHBlb3BsZS5hc0VudW1lcmFibGUoKS5qb2luKHBldHMsXFxyXFxuICAgIChwZXJzb24sIHBldCkgPT4gKHsgb3duZXJOYW1lOiBwZXJzb24ubmFtZSwgcGV0OiBwZXQubmFtZSB9KSxcXHJcXG4gICAgcGVyc29uID0+IHBlcnNvbixcXHJcXG4gICAgcGV0ID0+IHBldC5vd25lcik7XFxyXFxuXFxyXFxuZm9yIChsZXQgb2JqIG9mIHF1ZXJ5KSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKGAkeyBvYmoub3duZXJOYW1lIH0gLSAkeyBvYmoucGV0IH1gKTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4gVGhpcyBjb2RlIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmcgb3V0cHV0OlxcclxcblxcclxcbiBIZWRsdW5kLCBNYWdudXMgLSBEYWlzeVxcclxcbiBBZGFtcywgVGVycnkgLSBCYXJsZXlcXHJcXG4gQWRhbXMsIFRlcnJ5IC0gQm9vdHNcXHJcXG4gV2Vpc3MsIENoYXJsb3R0ZSAtIFdoaXNrZXJzXFxyXFxuICovJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHt0aXRsZTonQWN0aW9uJyxjb250ZW50czpbe3RpdGxlOlwiV2hhdCdzIHRoZSBBY3Rpb25cIixkZXNjcmlwdGlvbnM6W3tjb250ZW50OidBY3Rpb24gaXMgYSBmdW5jdGlvbiB3aGljaCBpcyBvbmx5IGV4ZWN1dGUgc29tZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHBhcmFtZXRlcnMnfSx7Y29udGVudDonVGhlIEFjdGlvbiBmdW5jdGlvbiBhY2NlcHQgb25lIHBhcmFtZXRlciwgb3IgYWNjZXB0IGFub3RoZXIgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGluIHRoZSBlbnVtZXJhYmxlIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCB0aGVuIGV4ZWN1dGUgc29tZSBjYWxjdWxhdGlvbiBidXQgcmV0dXJuIG5vdGhpbmcnfSx7fV19XX0iLCJtb2R1bGUuZXhwb3J0cyA9IHt0aXRsZTonQ29tcGFyZXInfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidDb25maWd1cmF0aW9uJ30iLCJtb2R1bGUuZXhwb3J0cyA9IHt0aXRsZTonR2V0IElFbnVtZXJhYmxlIGluc3RhbmNlJyxjb250ZW50czpbe3RpdGxlOidVc2UgY29uc3RydWN0b3Igb2YgRW51bWVyYWJsZSBjbGFzcycsZGVzY3JpcHRpb25zOlt7Y29udGVudDonWW91IGNhbiB1c2UgY29uc3RydWN0b3Igb2YgRW51bWVyYWJsZSBjbGFzcyBmb3IgZ2V0IGFuIElFbnVtZXJhYmxlIG9iamVjdCd9XX0se3RpdGxlOidVc2UgRW51bWVyYWJsZS5hc0VudW1lcmFibGUgbWV0aG9kJ30se3RpdGxlOidVc2UgYXNFbnVtZXJhYmxlIG1ldGhvZCcsZGVzY3JpcHRpb25zOlt7Y29udGVudDonQWZ0ZXIgcmVxdWlyZSBsaW5xLWpzLCBhc0VudW1lcmFibGUgbWV0aG9kIHdhciBpbmNsdWRlZCBieSBhbnkgb2JqZWN0LCB5b3UgY2FuIHVzZSBhc0VudW1lcmFibGUgb2YgYW55IG9iamVjdCBmb3IgZ2V0IGFuIElFbnVtZXJhYmxlIG9iamVjdCd9XX1dfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidQcmVkaWNhdGUnfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidTZWxlY3RvcicsY29udGVudHM6W3t0aXRsZTpcIldoYXQncyB0aGUgU2VsZWN0b3JcIixkZXNjcmlwdGlvbnM6W3tjb250ZW50OidUaGUgU2VsZWN0b3IgaXMgYSBmdW5jdGlvbiB3aGljaCBtYXBwaW5nIGFuIGlucHV0IHZhbHVlIHRvIGFuIG91dHB1dCB2YWx1ZS4nfSx7Y29udGVudDonVGhlIGZ1bmN0aW9uIGFjY2VwdCBvbmUgb3IgbW9yZSBhcmd1bWVudHMsIHNvbWV0aW1lcywgaXQgYWxzbyBhY2NlcHQgaW5kZXggb2YgdGhlIGNvbGxlY3Rpb24gYXMgYXJndW1lbnQuJ31dfSx7dGl0bGU6J1VuYXJ5IFNlbGVjdG9yJ30se3RpdGxlOidCaW5hcnkgU2VsZWN0b3InfSx7dGl0bGU6J1VzZSBzdHJpbmcvbnVtYmVyL3N5bWJvbCB2YWx1ZSB0byByZXBsYWNlIHRoZSBTZWxlY3RvcicsZGVzY3JpcHRpb25zOlt7Y29udGVudDonWW91IGNhbiB1c2UgYSBzdHJpbmcgb3IgYSBudW1iZXIgb3IgYSBzeW1ib2wgdmFsdWUgdG8gcmVwbGFjZSBhbiBVbmFyeSBTZWxlY3RvciwgdGhlIGV4YW1wbGVzIGZvbGxvd2luZyB3aWxsIHNob3cgeW91IGhvdyB0byB1c2Ugc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byByZXBsYWNlIHRoZSBTZWxlY3Rvcid9XX1dfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidTdGFydCB1c2UnfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidJbnN0YWxsJyxjb250ZW50czpbe3RpdGxlOidBZGQgdG8gcHJvamVjdCd9LHt0aXRsZTonUmVxdWlyZScsZGV0YWlsczpbe3JlbWFya3M6WydkZXNjcmlwdGlvbjpUaGlzIG1vZHVsZSByZXF1aXJlIEVTNi4gSSBzdWdnZXN0IHlvdSB0byB1c2UgdGhpcyB3aXRoIEVTNi4gVGhlIGZvbGxvd2luZyBleGFtcGxlcyBpcyBhbHJlYWR5IHVzZSBFUzYuJ119XX1dfSIsIm1vZHVsZS5leHBvcnRzID0ge3RpdGxlOidJbnRyb2R1Y3Rpb24nLGNvbnRlbnRzOlsndXNlIGxpbnEgYW5kIGxhbWJkYSBpbiBqYXZhc2NyaXB0IGZvciBlczYnLCcmbmJzcDsnLCcnLCdTaW5jZSAyLjEuMCwgSSByZXdyaXRlIGFsbCB0byB1c2UgbmV3IGZlYXR1cmVzIG9mIEVTNi4gVGhlIHBlcmZvcm1hbmNlIGJlIGJldHRlciwgbWVtb3J5IGlzIHVzZWQgbGVzcyBhbmQgdXNpbmcgZGVmZXJyZWQgZXhlY3V0aW9uLicsJyZuYnNwOycsJ015IEVuZ2xpc2ggaXMgcG9vciEnXX0iLCJtb2R1bGUuZXhwb3J0cyA9IHtuYW1lOidFbmdsaXNoJ30iXSwic291cmNlUm9vdCI6IiJ9